<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<HTML>
  <HEAD>
    <TITLE>DSpace System Documentation: Business Logic Layer</TITLE>
    <LINK REL=StyleSheet HREF="style.css" TYPE="text/css">
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" >
  </HEAD>
  <BODY>
    <H1>DSpace System Documentation: Business Logic Layer</H1>

    <P><A HREF="index.html">Back to contents</A><BR><A HREF="architecture.html">Back to architecture overview</A></P>

    <H2><A NAME="core">Core Classes</A></H2>

    <P>The <code>org.dspace.core</code> package provides some basic classes that are used throughout the DSpace code.</P>

    <H3>The Configuration Manager (<code>ConfigurationManager</code>)</H3>

    <P>The configuration manager is responsible for reading the main <code>dspace.cfg</code> properties file, managing the 'template' configuration files for other applications such as Apache, and for obtaining the text for e-mail messages.</P>

    <P>The system is configured by editing the relevant files in <code>/dspace/config</code>, as described in the <a href="configure.html">configuration section</a>.</p>

    <P><strong>When editing configuration files for applications that DSpace uses, such as Apache, remember to edit the file in <code>/dspace/config/templates</code> and then run <code>/dspace/bin/install-configs</code> rather than editing the 'live' version directly!</strong></P>

    <P>The <code>ConfigurationManager</code> class can also be invoked as a command line tool, with two possible uses:</P>

    <UL>
      <LI>
        <PRE><code>/dspace/bin/install-configs</code></PRE>
        <P>This processes and installs configuration files for other applications, as described in the <A HREF="configure.html#templates">configuration section</A>.</P>
      </LI>
      <LI>
        <PRE><code>/dspace/bin/dsrun org.dspace.core.ConfigurationManager -property property.name</code></PRE>
        <P>This writes the value of <code>property.name</code> from <code>dspace.cfg</code> to the standard output, so that shell scripts can access the DSpace configuration.  For an example, see <code>/dspace/bin/start-handle-server</code>.  If the property has no value, nothing is written.</P>
      </LI>
    </UL>


    <H3>Constants</H3>

    <P>This class contains constants that are used to represent types of object and actions in the database.  For example, authorization policies can relate to objects of different types, so the <code>resourcepolicy</code> table has columns <code>resource_id</code>, which is the internal ID of the object, and <code>resource_type_id</code>, which indicates whether the object is an item, collection, bitstream etc.  The value of <code>resource_type_id</code> is taken from the <code>Constants</code> class, for example <code>Constants.ITEM</code>.</P>


    <H3>Context</H3>

    <P>The <code>Context</code> class is central to the DSpace operation.  Any code that wishes to use the any API in the business logic layer must first create itself a <code>Context</code> object.  This is akin to opening a connection to a database (which is in fact one of the things that happens.)</P>

    <P>A context object is involved in most method calls and object constructors, so that the method or object has access to information about the current operation.  When the context object is constructed, the following information is automatically initialized:</P>

    <UL>
      <LI><P>A connection to the database.  This is a transaction-safe connection. i.e. the 'auto-commit' flag is set to false.</P></LI>
      <LI><P>A cache of content management API objects.  Each time a content object is created (for example <code>Item</code> or <code>Bitstream</code>) it is stored in the <code>Context</code> object.  If the object is then requested again, the cached copy is used.  Apart from reducing database use, this addresses the problem of having two copies of the same object in memory in different states.</P></LI>
    </UL>

    <P>The following information is also held in a context object, though it is the responsiblity of the application creating the context object to fill it out correctly:</P>

    <UL>
      <LI><P>The current authenticated user, if any</P></LI>
      <LI><P>Any 'special groups' the user is a member of.  For example, a user might automatically be part of a particular group based on the IP address they are accessing DSpace from, even though they don't have an e-person record.  Such a group is called a 'special group'.</P></LI>
      <LI><P>Any extra information from the application layer that should be added to log messages that are written within this context.  For example, the Web UI adds a session ID, so that when the logs are analysed the actions of a particular user in a particular session can be tracked.</P></LI>
      <LI>
        <P>A flag indicating whether authorization should be circumvented.  This should only be used in rare, specific circumstances.  For example, when first installing the system, there are no authorized administrators who would be able to create an administrator account!</P>
        <P>As noted above, the public API is <em>trusted</em>, so it is up to applications in the application layer to use this flag responsibly.</P>
      </LI>
    </UL>

    <P>Typical use of the context object will involve constructing one, and setting the current user if one is authenticated.  Several operations may be performed using the context object. If all goes well, <code>complete</code> is called to commit the changes and free up any resources used by the context.  If anything has gone wrong, <code>abort</code> is called to roll back any changes and free up the resources.</P>

    <P>You should always <code>abort</code> a context if <em>any</em> error happens during its lifespan; otherwise the data in the system may be left in an inconsistent state.  You can also <code>commit</code> a context, which means that any changes are written to the database, and the context is kept active for further use.</P>


    <H3>Email</H3>

    <P>Sending e-mails is pretty easy.  Just use the configuration manager's <code>getEmail</code> method, set the arguments and recipients, and send.</P>

    <P>The e-mail texts are stored in <code>/dspace/config/emails</code>.  They are processed by the standard <code>java.text.MessageFormat</code>.  At the top of each e-mail are listed the appropriate arguments that should be filled out by the sender.  Example usage is shown in the <code>org.dspace.core.Email</code> Javadoc API documentation.</P>


    <H3>LogManager</H3>

    <P>The log manager consists of a method that creates a standard log header, and returns it as a string suitable for logging.  Note that this class does not actually write anything to the logs; the log header returned should be logged directly by the sender using an appropriate Log4J call, so that information about where the logging is taking place is also stored.</P>

    <P>The level of logging can be configured on a per-package or per-class basis by editing <code>/dspace/config/templates/log4j.properties</code> and then executing <code>/dspace/bin/install-configs</code>.  You will need to stop and restart Tomcat for the changes to take effect.</P>

    <P>A typical log entry looks like this:</P>

    <P><code>2002-11-11 08:11:32,903 INFO  org.dspace.app.webui.servlet.DSpaceServlet @ anonymous:session_id=BD84E7C194C2CF4BD0EC3A6CAD0142BB:view_item:handle=1721.1/1686</code></P>

    <P>This is breaks down like this:</P>

    <table>
      <tr>
        <td>Date and time, milliseconds</td>
        <td><code>2002-11-11 08:11:32,903</code></td>
      </tr>
      <tr>
        <td>Level (<code>FATAL</code>, <code>WARN</code>, <code>INFO</code> or <code>DEBUG</code>)</td>
        <td><code>INFO</code></td>
      </tr>
      <tr>
        <td>Java class</td>
        <td><code>org.dspace.app.webui.servlet.DSpaceServlet</code></td>
      </tr>
      <tr>
        <td></td>
        <td><code>@</code></td>
      </tr>
      <tr>
        <td>User email or <code>anonymous</code></td>
        <td><code>anonymous</code></td>
      </tr>
      <tr>
        <td></td>
        <td><code>:</code></td>
      </tr>
      <tr>
        <td>Extra log info from context</td>
        <td><code>session_id=BD84E7C194C2CF4BD0EC3A6CAD0142BB</code></td>
      </tr>
      <tr>
        <td></td>
        <td><code>:</code></td>
      </tr>
      <tr>
        <td>Action</td>
        <td><code>view_item</code></td>
      </tr>
      <tr>
        <td></td>
        <td><code>:</code></td>
      </tr>
      <tr>
        <td>Extra info</td>
        <td><code>handle=1721.1/1686</code></td>
      </tr>
    </table>

    <P>The above format allows the logs to be easily parsed and analysed.  The <code>/dspace/bin/log-reporter</code> script is a simple tool for analysing logs.  Try:</P>

    <PRE>/dspace/bin/log-reporter --help</PRE>

    <P>It's a good idea to 'nice' this log reporter to avoid an impact on server performance.</P>


    <H3>Utils</H3>

    <P><code>Utils</code> comtains miscellaneous utility method that are required in a variety of places throughout the code, and thus have no particular 'home' in a subsystem.</P>


    <H2><A NAME="content">Content Management API</A></H2>

    <P>The content management API package <code>org.dspace.content</code> contains Java classes for reading and manipulating content stored in the DSpace system.  This is the API that components in the application layer will probably use most.</P>

    <P>Classes corresponding to the main elements in the <A HREF="functional.html#data_model">DSpace data model</A> (<code>Community</code>, <code>Collection</code>, <code>Item</code>, <code>Bundle</code> and <code>Bitstream</code>) are sub-classes of the abstract class <code>DSpaceObject</code>.  The <code>Item</code> object handles the Dublin Core metadata record.</P>

    <P>Each class generally has one or more static <code>find</code> methods, which are used to instantiate content objects.  Constructors do not have public access and are just used internally.  The reasons for this are:</P>

    <UL>
      <LI><P>"Constructing" an object may be misconstrued as the action of creating an object in the DSpace system, for example one might expect something like:</P>

      <PRE>Context dsContent = new Context();
Item myItem = new Item(context, id)</PRE>

      <P>to construct a brand new item in the system, rather than simply instantiating an in-memory instance of an object in the system.</P></LI>

      <LI><P><code>find</code> methods may often be called with invalid IDs, and return <code>null</code> in such a case.  A constructor would have to throw an exception in this case.  A <code>null</code> return value from a static method can in general be dealt with more simply in code.</P></LI>

      <LI><P>If an instantiation representing the same underlying archival entity already exists, the <code>find</code> method can simply return that same instantiation to avoid multiple copies and any inconsistencies which might result.</P></LI>
    </UL>

    <P><code>Collection</code>, <code>Bundle</code> and <code>Bitstream</code> do not have <code>create</code> methods; rather, one has to create an object using the relevant method on the container.  For example, to create a collection, one must invoke <code>createCollection</code> on the community that the collection is to appear in:</P>

    <PRE>Context context = new Context();
Community existingCommunity = Community.find(context, 123);
Collection myNewCollection = existingCommunity.createCollection();</PRE>

    <P>The primary reason for this is for determining authorization.  In order to know whether an e-person may create an object, the system must know which container the object is to be added to.  It makes no sense to create a collection outside of a community, and the authorization system does not have a policy for that.</P>

    <P><code>Item</code>s are first created in the form of an implementation of <code>InProgressSubmission</code>.  An <code>InProgressSubmission</code> represents an item under construction; once it is complete, it is installed into the main archive and added to the relevant collection by the <code>InstallItem</code> class.  The <code>org.dspace.content</code> package provides an implementation of <code>InProgressSubmission</code> called <code>WorkspaceItem</code>; this is a simple implementation that contains some fields used by the Web submission UI.  The <code>org.dspace.workflow</code> also contains an implementation called <code>WorkflowItem</code> which represents a submission undergoing a workflow process.</P>

    <P>In the previous chapter there is an <A HREF="functional.html#ingest">overview of the item ingest process</A> which should clarify the previous paragraph.  Also see the section on <A HREF="#workflow">the workflow system</A>.</P>

    <P><code>Community</code> and <code>BitstreamFormat</code> do have static <code>create</code> methods; one must be a site administrator to have authorization to invoke these.</P>


    <H3>Other Classes</H3>

    <P>Classes whose name begins <code>DC</code> are for manipulating Dublin Core metadata, as <A HREF="#dublincore">explained below</A>.</P>

    <P>The <code>FormatIdentifier</code> class attempts to guess the bitstream format of a particular bitstream.  Presently, it does this simply by looking at any file extension in the bitstream name and matching it up with the file extensions associated with bitstream formats.  Hopefully this can be greatly improved in the future!</P>

    <P>The <code>ItemIterator</code> class allows items to be retrieved from storage one at a time, and is returned by methods that may return a large number of items, more than would be desirable to have in memory at once.</P>

    <P>The <code>ItemComparator</code> class is an implementation of the standard <code>java.util.Comparator</code> that can be used to compare and order items based on a particular Dublin Core metadata field.</P>



    <H3>Modifications</H3>

    <P>When creating, modifying or for whatever reason removing data with the content management API, it is important to know when changes happen in-memory, and when they occur in the physical DSpace storage.</P>

    <P>Primarily, one should note that no change made using a particular <code>org.dspace.core.Context</code> object will actually be made in the underlying storage unless <code>complete</code> or <code>commit</code> is invoked on that <code>Context</code>.  If anything should go wrong during an operation, the context should always be aborted by invoking <code>abort</code>, to ensure that no inconsistent state is written to the storage.</P>

    <P>Additionally, some changes made to objects only happen in-memory.  In these cases, invoking the <code>update</code> method lines up the in-memory changes to occur in storage when the <code>Context</code> is committed or completed.  In general, methods that change any [meta]data field only make the change in-memory; methods that involve relationships with other objects in the system line up the changes to be committed with the context.  See individual methods in the API Javadoc.</P>

    <P>Some examples to illustrate this are shown below:</P>

    <TABLE>
      <TR>
        <TD><PRE>Context context = new Context();
Bitstream b = Bitstream.find(context, 1234);
b.setName("newfile.txt");
b.update();
context.complete();</PRE>
        </TD>
        <TD><strong>Will</strong> change storage</TD>
      </TR>
      <TR>
        <TD><PRE>Context context = new Context();
Bitstream b = Bitstream.find(context, 1234);
b.setName("newfile.txt");
b.update();
context.abort();</PRE>
        </TD>
        <TD><strong>Will not</strong> change storage (context aborted)</TD>
      </TR>
      <TR>
        <TD><PRE>Context context = new Context();
Bitstream b = Bitstream.find(context, 1234);
b.setName("newfile.txt");
context.complete();</PRE>
        </TD>
        <TD>The new name <strong>will not</strong> be stored since <code>update</code> was not invoked</TD>
      </TR>
      <TR>
        <TD><PRE>Context context = new Context();
Bitstream bs = Bitstream.find(context, 1234);
Bundle bnd = Bundle.find(context, 5678);
bnd.add(bs);
context.complete();</PRE>
        </TD>
        <TD>The bitstream <strong>will</strong> be included in the bundle, since <code>update</code> doesn't need to be called</TD>
      </TR>
    </TABLE>


    <H3>What's In Memory?</H3>

    <P>Instantiating some content objects also causes other content objects to be loaded into memory.</P>

    <P>Instantiating a <code>Bitstream</code> object causes the appropriate <code>BitstreamFormat</code> object to be instantiated.  Of course the <code>Bitstream</code> object does not load the underlying bits from the bitstream store into memory!</P>

    <P>Instantiating a <code>Bundle</code> object causes the appropriate <code>Bitstream</code> objects (and hence <code>BitstreamFormat</code>s) to be instantiated.</P>

    <P>Instantiating an <code>Item</code> object causes the appropriate <code>Bundle</code> objects (etc.) and hence <code>BitstreamFormat</code>s to be instantiated.  All the Dublin Core metadata associated with that item are also loaded into memory.</P>

    <P>The reasoning behind this is that for the vast majority of cases, anyone instantiating an item object is going to need information about the bundles and bitstreams within it, and this methodology allows that to be done in the most efficient way and is simple for the caller.  For example, in the Web UI, the servlet (controller) needs to pass information about an item to the viewer (JSP), which needs to have all the information in-memory to display the item without further accesses to the database which may cause errors mid-display.</P>

    <P>You do not need to worry about multiple in-memory instantiations of the same object, or any inconsistenties that may result; the <code>Context</code> object keeps a cache of the instantiated objects.  The <code>find</code> methods of classes in <code>org.dspace.content</code> will use a cached object if one exists.</P>

    <P>It may be that in enough cases this automatic instantiation of contained objects reduces performance in situations where it is important; if this proves to be true the API may be changed in the future to include a <code>loadContents</code> method or somesuch, or perhaps a Boolean parameter indicating what to do will be added to the <code>find</code> methods.</P>

    <P>When a <code>Context</code> object is completed, aborted or garbage-collected, any objects instantiated using that context are invalidated and should not be used (in much the same way an AWT button is invalid if the window containing it is destroyed).</P>


    <H3><A NAME="dublincore">Dublin Core Metadata</A></H3>

    <P>The <code>DCValue</code> class is a simple container that represents a single Dublin Core element, optional qualifier, value and language.  Note that as of DSpace 1.4 the <code>MetadataValue</code> and associated classes are preferred (see <a href="#otherschemas">Support for Other Metadata Schemas</a>). The other classes starting with <code>DC</code> are utility classes for handling types of data in Dublin Core, such as people's names and dates.  As supplied, the DSpace registry of elements and qualifiers corresponds to the <A HREF="http://www.dublincore.org/documents/2002/09/24/library-application-profile/">Library Application Profile</A> for Dublin Core.  It should be noted that these utility classes assume that the values will be in a certain syntax, which will be true for all data generated within the DSpace system, but since Dublin Core does not always define strict syntax, this may not be true for Dublin Core originating outside DSpace.</P>

    <P>Below is the specific syntax that DSpace expects various fields to adhere to:</P>

    <TABLE>
      <TR>
        <TH>Element</TH>
        <TH>Qualifier</TH>
        <TH>Syntax</TH>
        <TH>Helper Class</TH>
      </TR>
      <TR>
        <TD><code>date</code></TD>
        <TD>Any or unqualified</TD>
        <TD>
          <P>ISO 8601 in the UTC time zone, with either year, month, day, or second precision.  Examples:</P>
          <PRE>2000
2002-10
2002-08-14
1999-01-01T14:35:23Z</PRE>
        </TD>
        <TD><code>DCDate</code></TD>
      </TR>
      <TR>
        <TD><code>contributor</code></TD>
        <TD>Any or unqualified</TD>
        <TD>
          <P>In general last name, then a comma, then first names, then any additional information like "Jr.".  If the contributor is an organization, then simply the name.  Examples:</P>
          <PRE>Doe, John
Smith, John Jr.
van Dyke, Dick
Massachusetts Institute of Technology</PRE>
        </TD>
        <TD><code>DCPersonName</code></TD>
      </TR>
      <TR>
        <TD><code>language</code></TD>
        <TD><code>iso</code></TD>
        <TD>
          <P>A two letter code taken ISO 639, followed optionally by a two letter country code taken from ISO 3166.  Examples:</P>
          <PRE>en
fr
en_US</PRE>
        </TD>
        <TD><code>DCLanguage</code></TD>
      </TR>
      <TR>
        <TD><code>relation</code></TD>
        <TD><code>ispartofseries</code></TD>
        <TD>
          <P>The series name, following by a semicolon followed by the number in that series.  Alternatively, just free text.</P>
          <PRE>MIT-TR; 1234
My Report Series; ABC-1234
NS1234</PRE>
        </TD>
        <TD><code>DCSeriesNumber</code></TD>
      </TR>
    </TABLE>

   <h3><a name="otherschemas">Support for Other Metadata Schemas</a></h3>

   <p>To support additional metadata schemas a new set of metadata classes have been added. These are backwards compatible with the DC classes and should be used rather than the DC specific classes whereever possible. Note that hierarchical metadata schemas are not currently supported, only flat schemas (such as DC) are able to be defined.</p>

   <p>The <code>MetadataField</code> class describes a metadata field by schema, element and optional qualifier. The value of a <code>MetadataField</code> is described by a <code>MetadataValue</code> which is roughly equivalent to the older <code>DCValue</code> class. Finally the <code>MetadataSchema</code> class is used to describe supported schemas. The DC schema is supported by default. Refer to the javadoc for method details.</p>

  <h3><a name="packager">Packager Plugins</a></h3>

  <p>The Packager plugins let you <em>ingest</em> a package to create a new DSpace Object, and <em>disseminate</em> a content Object as a package. A package is simply a data stream; its contents are defined by the
packager plugin's implementation.</p>

  <p>To ingest an object, which is currently only implemented for Items, the sequence of operations is:
    <ol>
       <li>Get an instance of the chosen <code>PackageIngester</code> plugin.</li>
       <li>Locate a Collection in which to create the new Item.</li>
       <li>Call its <code>ingest</code> method, and get back a <code>WorkspaceItem</code>.</li>
    </ol>

  <p>The packager also takes a <code>PackageParameters</code> object, which is a property list of parameters specific to that packager which might be passed in from the user interface.</p>

  <p>Here is an example package ingestion code fragment:
  <pre>    Collection collection = <em>find target collection</em>
     InputStream source = ...;
     PackageParameters params = ...;
     String license = null;

    PackageIngester sip = (PackageIngester) PluginManager
            .getNamedPlugin(PackageIngester.class, packageType);

    WorkspaceItem wi = sip.ingest(context, collection, source, params, license);</pre></p>

    <p>Here is an example of a package dissemination:
    <pre>    OutputStream destination = ...;
     PackageParameters params = ...;
     DSpaceObject dso = ...;

     PackageIngester dip = (PackageDisseminator) PluginManager
             .getNamedPlugin(PackageDisseminator.class, packageType);

     dip.disseminate(context, dso, params, destination);</pre></p>


    <h2><a name="plugin">Plugin Manager</a></h2>

    <p>The PluginManager is a very simple component container. It creates and organizes components (plugins), and helps select a plugin in the cases where there are many possible choices. It also gives some limited control over the lifecycle of a plugin.</p>

    <h3>Concepts</h3>

    <p>The following terms are important in understanding the rest of this section:

    <ul>
    <li><strong>Plugin Interface</strong>
    <p>A Java interface, the defining characteristic of a plugin. The consumer of a plugin asks for its plugin by interface.</p></li>
    <li><strong>Plugin</strong>

    <p>a.k.a. Component, this is an instance of a class that implements a certain interface. It is interchangeable with other implementations, so that any of them may be "plugged in", hence the name. A Plugin is an instance of any class that implements the plugin interface.</p></li>

    <li><strong>Implementation class</strong>

    <p>The actual class of a plugin. It may implement several plugin interfaces, but must implement at least one.</p></li>

   <li><strong>Name</strong>

    <p>Plugin implementations can be distinguished from each other by name, a short String meant to symbolically represent the implementation class. They are called "named plugins". Plugins only need to be named when the caller has to make an active choice between them.</p></li>

    <li><strong>SelfNamedPlugin class</strong>

    <p>Plugins that extend the <code>SelfNamedPlugin</code> class can take advantage of additional features of the Plugin Manager. Any class can be managed as a plugin, so it is not necessary, just possible.</p></li>

    <li><strong>Reusable</strong>

    <p>Reusable plugins are only instantiated once, and the Plugin Manager returns the same (cached) instance whenever that same plugin is requested again. This behavior can be turned off if desired.</p></li>
    </ul></p>

    <h3>Using the Plugin Manager</h3>

    <h4>Types of Plugin</h4>

    <p>The Plugin Manager supports three different patterns of usage: 
    <ol>
    <li><strong>Singleton Plugins</strong>

    <p>There is only one implementation class for the plugin. It is indicated in the configuration. This type of plugin chooses an implementations of a service, for the entire system, at configuration time. Your application just fetches the plugin for that interface and gets the configured-in choice. See the <a href="#pluginmethods">getSinglePlugin()</a> method.</p></li>

    <li><strong>Sequence Plugins</strong>

    <p>You need a sequence or series of plugins, to implement a mechanism like Stackable Authentication or a pipeline, where each plugin is called in order to contribute its implementation of a process to the whole. The Plugin Manager supports this by letting you configure a sequence of plugins for a given interface. See the <a href="#pluginmethods">getPluginSequence()</a> method.</p></li>

    <li><strong>Named Plugins</strong>

    <p>Use a named plugin when the application has to choose one plugin implementation out of many available ones. Each implementation is bound to one or more names (symbolic identifiers) in the configuration.</p>

    <p>The name is just a string to be associated with the combination of implementation class and interface. It may contain any characters except for comma (,) and equals (=). It may contain embedded spaces. Comma is a special character used to separate names in the configuration entry.</p>

    <p>Names must be unique within an interface: No plugin classes implementing the same interface may have the same name.</p>

    <p>Think of plugin names as a controlled vocabulary -- for a given plugin interface, there is a set of names for which plugins can be found. The designer of a Named Plugin interface is responsible for deciding what the name means and how to derive it; for example, names of metadata crosswalk plugins may describe the target metadata format.</p>

    <p>See the <a href="#pluginmethods">getNamedPlugin()</a> method and the getPluginNames() methods.</p></li>
    </ol></p>

    <h4><a name="selfnamedplugin">Self-Named Plugins</a></h4>

    <p>Named plugins can get their names either from the configuration or, for a variant called self-named plugins, from within the plugin itself.</p>

    <p>Self-named plugins are necessary because one plugin implementation can be configured itself to take on many "personalities", each of which deserves its own plugin name. It is already managing its own configuration for each of these personalities, so it makes sense to allow it to export them to the Plugin Manager rather than expecting the plugin configuration to be kept in sync with it own configuration.</p>

   <p>An example helps clarify the point: There is a named plugin that does crosswalks, call it <code>CrosswalkPlugin</code>. It has several implementations that crosswalk some kind of metadata. Now we add a new plugin which uses XSL stylesheet transformation (XSLT) to crosswalk many types of metadata -- so the single plugin can act like many different plugins, depending on which stylesheet it employs.</p>

   <p>This XSLT-crosswalk plugin has its own configuration that maps a Plugin Name to a stylesheet -- it has to, since of course the Plugin Manager doesn't know anything about stylesheets. It becomes a self-named plugin, so that it reads its configuration data, gets the list of names to which it can respond, and passes those on to the Plugin Manager.</p>

   <p>When the Plugin Manager creates an instance of the XSLT-crosswalk, it records the Plugin Name that was responsible for that instance. The plugin can look at that Name later in order to configure itself correctly for the Name that created it. This mechanism is all part of the SelfNamedPlugin class which is part of any self-named plugin.</p>

   <h4>Obtaining a Plugin Instance</h4>

   <p>The most common thing you will do with the Plugin Manager is obtain an instance of a plugin. To request a plugin, you must always specify the plugin interface you want. You will also supply a name when asking for a named plugin.</p>

  <p>A sequence plugin is returned as an array of <code>Object</code>s since it is actually an ordered list of plugins.</p>

  <p>See the <a href="#pluginmethods">getSinglePlugin(), getPluginSequence(), getNamedPlugin()</a> methods.<p>

  <h4>Lifecycle Management</h4>

  <p>When <code>PluginManager</code> fulfills a request for a plugin, it checks whether the implementation class is reusable; if so, it creates one instance of that class and returns it for every subsequent request for that interface and name. If it is not reusable, a new instance is always created.</p>

  <p>For reasons that will become clear later, the manager actually caches a separate instance of an implementation class for each name under which it can be requested.</p>

  <p>You can ask the <code>PluginManager</code> to forget about (decache) a plugin instance, by releasing it. See the <a href="#pluginmethods">PluginManager.releasePlugin()</a> method. The manager will drop its reference to the plugin so the garbage collector can reclaim it. The next time that plugin/name combination is requested, it will create a new instance.</p>

  <h4>Getting Meta-Information</h4>

  <p>The <code>PluginManager</code> can list all the names of the Named Plugins which implement an interface. You may need this, for example, to implement a menu in a user interface that presents a choice among all possible plugins. See the <a href="#pluginmethods">getPluginNames()</a> method.</p>

  <p>Note that it only returns the plugin name, so if you need a more sophisticated or meaningful "label" (i.e. a key into the I18N message catalog) then you should add a method to the plugin itself to return that.</p>

  <h3>Implementation</h3>

  <p>Note: The <code>PluginManager</code> refers to interfaces and classes internally only by their names whenever possible, to avoid loading classes until absolutely necessary (i.e. to create an instance). As you'll see below, self-named classes still have to be loaded to query them for names, but for the most part it can avoid loading classes. This saves a lot of time at start-up and keeps the JVM memory footprint down, too. As the Plugin Manager gets used for more classes, this will become a greater concern.</code>

  <p>The only downside of "on-demand" loading is that errors in the configuration don't get discovered right away. The solution is to call the <code>checkConfiguration()</code> method after making any changes to the configuration.</p>

  <h4><a name="pluginmethods">PluginManager Class</a></h4>

  <p>The <code>PluginManager</code> class is your main interface to the Plugin Manager. It behaves like a factory class that never gets instantiated, so its public methods are static.</p>

  <p>Here are the public methods, followed by explanations:
  <ul>
  <li><pre>static Object getSinglePlugin(Class intface)
    throws PluginConfigurationError;</pre>

  <p>Returns an instance of the singleton (single) plugin implementing the given interface. There must be exactly one single plugin configured for this interface, otherwise the <code>PluginConfigurationError</code> is thrown.</p>

  <p>Note that this is the only "get plugin" method which throws an exception. It is typically used at initialization time to set up a permanent part of the system so any failure is fatal.</p>

  <p>See the <code>plugin.single</code> configuration key for configuration details.</p></li>

  <li><code>static Object[] getPluginSequence(Class intface);</code>

  <p>Returns instances of all plugins that implement the interface <code>intface</code>, in an <code>Array</code>. Returns an empty array if no there are no matching plugins.</p>

  <p>The order of the plugins in the array is the same as their class names in the configuration's value field.</p>

  <p>See the <code>plugin.sequence</code> configuration key for configuration details.</p></li>

  <li><code>static Object getNamedPlugin(Class intface, String name);</code>

  <p>Returns an instance of a plugin that implements the interface <code>intface</code> and is bound to a name matching name. If there is no matching plugin, it returns null. The names are matched by <code>String.equals()</code>.

  <p>See the <code>plugin.named</code> and <code>plugin.selfnamed</code> configuration keys for configuration details.</p></li>

  <li><code>static void releasePlugin(Object plugin);</code>

  <p>Tells the Plugin Manager to let go of any references to a reusable plugin, to prevent it from being given out again and to allow the object to be garbage-collected. Call this when a plugin instance must be taken out of circulation.</p></li>

  <li><code>static String[] getAllPluginNames(Class intface);</code>

  <p>Returns all of the names under which a named plugin implementing the interface <code>intface</code> can be requested (with <code>getNamedPlugin()</code>). The array is empty if there are no matches. Use this to populate a menu of plugins for interactive selection, or to document what the possible choices are.</p>

  <p>The names are NOT returned in any predictable order, so you may wish to sort them first.</p>

  <p>Note: Since a plugin may be bound to more than one name, the list of names this returns does not represent the list of plugins. To get the list of unique implementation classes corresponding to the names, you might have to eliminate duplicates (i.e. create a Set of classes).</p></li>

  <li><code>static void checkConfiguration();</code>

  <p>Validates the keys in the DSpace <code>ConfigurationManager</code> pertaining to the Plugin Manager and reports any errors by logging them. This is intended to be used interactively by a DSpace administrator, to check the configuration file after modifying it. See the section about <a href="#confval">validating configuration</a> for details.</p></li>
  </ul></p>

  <h4>SelfNamedPlugin Class</h4>

  <p>A named plugin implementation must extend this class if it wants to supply its own Plugin Name(s). See <a href="#selfnamedplugin">Self-Named Plugins</a> for why this is sometimes necessary.</p>

<pre>abstract class SelfNamedPlugin
{
    // Your class must override this:
    // Return all names by which this plugin should be known.
    public static String[] getPluginNames();

    // Returns the name under which this instance was created.
    // This is implemented by SelfNamedPlugin and should NOT be overridden.
    public String getPluginInstanceName();
}</pre>

  <h4>Errors and Exceptions</h4>

<pre>public class PluginConfigurationError extends Error
{
    public PluginConfigurationError(String message);
}</pre>

  <p>An error of this type means the caller asked for a single plugin, but either there was no single plugin configured matching that interface, or there was more than one. Either case causes a fatal configuration error.</p>

<pre>public class PluginInstantiationException extends RuntimeException
{
    public PluginInstantiationException(String msg, Throwable cause)
}</pre>

  <p>This exception indicates a fatal error when instantiating a plugin class. It should only be thrown when something unexpected happens in the course of instantiating a plugin, e.g. an access error, class not found, etc. Simply not finding a class in the configuration is not an exception.</p>

  <p>This is a <code>RuntimeException</code> so it doesn't have to be declared, and can be passed all the way up to a generalized fatal exception handler.</p>

  <h3><a name="pluginconfig">Configuring Plugins</a></h3>

  <p>All of the Plugin Manager's configuration comes from the DSpace Configuration Manager, which is a Java Properties map. You can configure these characteristics of each plugin:
  <ol>
  <li><strong>Interface</strong>: Classname of the Java interface which defines the plugin, including package name. e.g. <code>org.dspace.app.mediafilter.FormatFilter</code></li>
  <li><strong>Implementation Class</strong>: Classname of the implementation class, including package. e.g. <code>org.dspace.app.mediafilter.PDFFilter</code></li>
  <li><strong>Names</strong>: (Named plugins only) There are two ways to bind names to plugins: listing them in the value of a plugin.named.interface key, or configuring a class in <code>plugin.selfnamed.<i>interface</i></code> which extends the <code>SelfNamedPlugin</code> class.</li>
  <li><strong>Reusable option</strong>: (Optional) This is declared in a <code>plugin.reusable</code> configuration line. Plugins are reusable by default, so you only need to configure the non-reusable ones.</li>
  </ol></p>

  <h4>Configuring Singleton (Single) Plugins</h4>

  <p>This entry configures a Single Plugin for use with getSinglePlugin():</p>

  <p><code>plugin.single.interface = classname</code></p>

  <p>For example, this configures the class <code>org.dspace.checker.SimpleDispatcher</code> as the plugin for interface <code>org.dspace.checker.BitstreamDispatcher</code>:</p>

  <p><code>plugin.single.org.dspace.checker.BitstreamDispatcher=org.dspace.checker.SimpleDispatcher</code></p>

  <h4>Configuring Sequence of Plugins</h4>

  <p>This kind of configuration entry defines a Sequence Plugin, which is bound to a sequence of implementation classes. The key identifies the interface, and the value is a comma-separated list of classnames:</p>

  <code>plugin.sequence.interface = classname, ... </code>

  <p>The plugins are returned by <code>getPluginSequence()</code> in the same order as their classes are listed in the configuration value.</p>

  <p>For example, this entry configures Stackable Authentication with three implementation classes:</p>

  <p><pre>plugin.sequence.org.dspace.eperson.AuthenticationMethod = \
            org.dspace.eperson.X509Authentication, \
            org.dspace.eperson.PasswordAuthentication, \
            edu.mit.dspace.MITSpecialGroup</pre></p>

  <h4>Configuring Named Plugins</h4>

  <p>There are two ways of configuring named plugins:
  <ol>
  <li><strong>Plugins Named in the Configuration</strong>

  <p>A named plugin which gets its name(s) from the configuration is listed in this kind of entry:</p>

  <p><code>plugin.named.interface = classname = name [ , name.. ] [ classname = name.. ]</code></p>

  <p>The syntax of the configuration value is: classname, followed by an equal-sign and then at least one plugin name. Bind more names to the same implementation class by by adding them here, separated by commas. Names may include any character other than comma (,) and equal-sign (=).</p>

  <p>For example, this entry creates one plugin with the names GIF, JPEG, and image/png, and another with the name TeX:</p>

  <p><pre>plugin.named.org.dspace.app.mediafilter.MediaFilter = \
        org.dspace.app.mediafilter.JPEGFilter = GIF, JPEG, image/png \
        org.dspace.app.mediafilter.TeXFilter = TeX</pre></p>

  <p>This example shows a plugin name with an embedded whitespace character. Since comma (,) is the separator character between plugin names, spaces are legal (between words of a name; leading and trailing spaces are ignored).</p>

  <p>This plugin is bound to the names "Adobe PDF", "PDF", and "Portable Document Format".</p>

  <p><pre>plugin.named.org.dspace.app.mediafilter.MediaFilter = \
      org.dspace.app.mediafilter.TeXFilter = TeX \
      org.dspace.app.mediafilter.PDFFilter =  Adobe PDF, PDF, Portable Document Format</pre></p>

  <p>NOTE: Since there can only be one key with plugin.named. followed by the interface name in the configuration, all of the plugin implementations must be configured in that entry.</p></li>

  <li><strong>Self-Named Plugins</strong>

  <p>Since a self-named plugin supplies its own names through a static method call, the configuration only has to include its interface and classname:</p>

  <p><code>plugin.selfnamed.interface = classname [ , classname.. ]</code></p>

  <p>The following example first demonstrates how the plugin class, <code>XsltDisseminationCrosswalk</code> is configured to implement its own names "MODS" and "DublinCore". These come from the keys starting with <code>crosswalk.dissemination.stylesheet.</code>. The value is a stylesheet file.</p>

  <p>The class is then configured as a self-named plugin:</p>

<p><pre>crosswalk.dissemination.stylesheet.DublinCore = xwalk/TESTDIM-2-DC_copy.xsl
crosswalk.dissemination.stylesheet.MODS = xwalk/mods.xsl

plugin.selfnamed.crosswalk.org.dspace.content.metadata.DisseminationCrosswalk = \
        org.dspace.content.metadata.MODSDisseminationCrosswalk, \
        org.dspace.content.metadata.XsltDisseminationCrosswalk</pre></p>

  <p>NOTE: Since there can only be one key with plugin.selfnamed. followed by the interface name in the configuration, all of the plugin implementations must be configured in that entry. The <code>MODSDisseminationCrosswalk</code> class is only shown to illustrate this point.</p></li>
  </ol></p>

  <h4>Configuring the Reusable Status of a Plugin</h4>

  <p>Plugins are assumed to be reusable by default, so you only need to configure the ones which you would prefer not to be reusable. The format is as follows:</p>

  <p><code>plugin.reusable.classname = ( true | false )</code></p>

  <p>For example, this marks the PDF plugin from the example above as non-reusable:</p>

  <p><code>plugin.reusable.org.dspace.app.mediafilter.PDFFilter = false</code></p>

  <h3><a name="confval">Validating the Configuration</a></h3>

  <p>The Plugin Manager is very sensitive to mistakes in the DSpace configuration. Subtle errors can have unexpected consequnces that are hard to detect: for example, if there are two "plugin.single" entries for the same interface, one of them will be silently ignored.</p>

  <p>To validate the Plugin Manager configuration, call the <code>PluginManager.checkConfiguration()</code> method. It looks for the following mistakes:
  <ul>
  <li>Any duplicate keys starting with "plugin.".</li>
  <li>Keys starting <code>plugin.single</code>, <code>plugin.sequence</code>, <code>plugin.named</code>, and <code>plugin.selfnamed</code> that don't include a valid interface.</li>
  <li>Classnames in the configuration values that don't exist, or don't implement the plugin interface in the key.</li>
  <li>Classes declared in plugin.selfnamed lines that don't extend the <code>SelfNamedPlugin</code> class.</li>
  <li>Any name collisions among named plugins for a given interface.</li>
  <li>Named plugin configuration entries without any names.</li>
  <li>Classnames mentioned in <code>plugin.reusable</code> keys must exist and have been configured as a plugin implementation class.</li>
  </ul></p>

  <p>The <code>PluginManager</code> class also has a <code>main()</code> method which simply runs <code>checkConfiguration()</code>, so you can invoke it from the command line to test the validity of plugin configuration changes.</p>

  <p>Eventually, someone should develop a general configuration-file sanity checker for DSpace, which would just call <code>PluginManager.checkConfiguration().</code></p>

  <h3>Use Cases<h3>

  <p>Here are some usage examples to illustrate how the Plugin Manager works.</p>

  <h4>Managing the MediaFilter plugins transparently</h4>

  <p>The existing DSpace 1.3 MediaFilterManager implementation have been largely replaced by the Plugin Manager. The MediaFilter classes become plugins named in the configuration. Refer to the <a href="configure.html#mediafilters">configuration guide</a> for further details.</p>

  <h4>A Singleton Plugin</h4>

  <p>This shows how to configure and access a single anonymous plugin, such as the BitstreamDispatcher plugin:</p>

   <p>Configuration:</p>

   <p><code>plugin.single.org.dspace.checker.BitstreamDispatcher=org.dspace.checker.SimpleDispatcher</code><p>

   <p>The following code fragment shows how dispatcher, the service object, is initialized and used:</p>

   <p><pre>BitstreamDispatcher dispatcher =
    (BitstreamDispatcher)PluginManager.getSinglePlugin(BitstreamDispatcher.class);

int id = dispatcher.next();

while (id != BitstreamDispatcher.SENTINEL)
{
     /*
        do some processing here
     */

     id = dispatcher.next();
}</pre></p>

  <h4>Plugin that Names Itself</h4>

  <p>This crosswalk plugin acts like many different plugins since it is configured with different XSL translation stylesheets. Since it already gets each of its stylesheets out of the DSpace configuration, it makes sense to have the plugin give PluginManager the names to which it answers instead of forcing someone to configure those names in two places (and try to keep them synchronized).</p>

  <p>NOTE: Remember how <code>getPlugin()</code> caches a separate instance of an implementation class for every name bound to it? This is why: the instance can look at the name under which it was invoked and configure itself specifically for that name. Since the instance for each name might be different, the Plugin Manager has to cache a separate instance for each name.</p>

  <p>Here is the configuration file listing both the plugin's own configuration and the <code>PluginManager</code> config line:</p>

<p><pre>crosswalk.dissemination.stylesheet.DublinCore = xwalk/TESTDIM-2-DC_copy.xsl
crosswalk.dissemination.stylesheet.MODS = xwalk/mods.xsl

plugin.selfnamed.org.dspace.content.metadata.DisseminationCrosswalk = \
  org.dspace.content.metadata.XsltDisseminationCrosswalk</pre></p>

<p>This look into the implementation shows how it finds configuration entries to populate the array of plugin names returned by the <code>getPluginNames()</code> method. Also note, in the <code>getStylesheet()</code> method, how it uses the plugin name that created the current instance (returned by <code>getPluginInstanceName()</code>) to find the correct stylesheet.</p>

<p><pre>public class XsltDisseminationCrosswalk extends SelfNamedPlugin
{
    ....
    private final String prefix = "crosswalk.dissemination.stylesheet.";
    ....
    public static String[] getPluginNames()
    {
        List aliasList = new ArrayList();
        Enumeration pe = ConfigurationManager.propertyNames();

        while (pe.hasMoreElements())
        {
            String key = (String)pe.nextElement();
            if (key.startsWith(prefix))
                aliasList.add(key.substring(prefix.length()));
        }
        return (String[])aliasList.toArray(new String[aliasList.size()]);
    }

    // get the crosswalk stylesheet for an instance of the plugin:
    private String getStylesheet()
    {
        return ConfigurationManager.getProperty(prefix + getPluginInstanceName());
    }
}</pre></p>

  <h4>Stackable Authentication</h4>

  <p>The Stackable Authentication mechanism needs to know all of the plugins configured for the interface, in the order of configuration, since order is significant. It gets a Sequence Plugin from the Plugin Manager. Refer to the <a href="configure.html#authenticate">configuration guide</a> for further details.</p>
  
    <H2><A NAME="workflow">Workflow System</A></H2>

    <P>The primary classes are:</P>

    <TABLE>
      <TR>
        <TD><code>org.dspace.content.WorkspaceItem</code></TD>
        <TD>contains an Item before it enters a workflow</TD>
      </TR>
      <TR>
        <TD><code>org.dspace.workflow.WorkflowItem</code></TD>
        <TD>contains an Item while in a workflow</TD>
      </TR>
      <TR>
        <TD><code>org.dspace.workflow.WorkflowManager</code></TD>
        <TD>responds to events, manages the WorkflowItem states</TD>
      </TR>
      <TR>
        <TD><code>org.dspace.content.Collection</code></TD>
        <TD>contains List of defined workflow steps</TD>
      </TR>
      <TR>
        <TD><code>org.dspace.eperson.Group</code></TD>
        <TD>people who can perform workflow tasks are defined in EPerson Groups</TD>
      </TR>
      <TR>
        <TD><code>org.dspace.core.Email</code></TD>
        <TD>used to email messages to Group members and submitters</TD>
      </TR>
    </TABLE>

    <P>The workflow system models the states of an Item in a state machine with 5 states (SUBMIT, STEP_1, STEP_2, STEP_3, ARCHIVE.)  These are the three optional steps where the item can be viewed and corrected by different groups of people.  Actually, it's more like 8 states, with STEP_1_POOL, STEP_2_POOL, and STEP_3_POOL.  These pooled states are when items are waiting to enter the primary states.</P>

    <P>The WorkflowManager is invoked by events.  While an Item is being submitted, it is held by a WorkspaceItem.  Calling the start() method in the WorkflowManager converts a WorkspaceItem to a WorkflowItem, and begins processing the WorkflowItem's state.  Since all three steps of the workflow are optional, if no steps are defined, then the Item is simply archived.</P>

    <P>Workflows are set per Collection, and steps are defined by creating corresponding entries in the List named workflowGroup.  If you wish the workflow to have a step 1, use the administration tools for Collections to create a workflow Group with members who you want to be able to view and approve the Item, and the workflowGroup[0] becomes set with the ID of that Group.</P>

    <P>If a step is defined in a Collection's workflow, then the WorkflowItem's state is set to that step_POOL.  This pooled state is the WorkflowItem waiting for an EPerson in that group to claim the step's task for that WorkflowItem.  The WorkflowManager emails the members of that Group notifying them that there is a task to be performed (the text is defined in config/emails,) and when an EPerson goes to their 'My DSpace' page to claim the task, the WorkflowManager is invoked with a claim event, and the WorkflowItem's state advances from STEP_x_POOL to STEP_x (where x is the corresponding step.)  The EPerson can also generate an 'unclaim' event, returning the WorkflowItem to the STEP_x_POOL.</P>

    <P>Other events the WorkflowManager handles are advance(), which advances the WorkflowItem to the next state.  If there are no further states, then the WorkflowItem is removed, and the Item is then archived.  An EPerson performing one of the tasks can reject the Item, which stops the workflow, rebuilds the WorkspaceItem for it and sends a rejection note to the submitter.  More drastically, an abort() event is generated by the admin tools to cancel a workflow outright.</P>


    <H2><A NAME="administer">Administration Toolkit</A></H2>

    <P>The <code>org.dspace.administer</code> package contains some classes for administering a DSpace system that are not generally needed by most applications.</P>

    <P>The <code>CreateAdministrator</code> class is a simple command-line tool, executed via <code>/dspace/bin/create-administrator</code>, that creates an administrator e-person with information entered from standard input.  This is generally used only once when a DSpace system is initially installed, to create an initial administrator who can then use the Web administration UI to further set up the system.  This script does not check for authorization, since it is typically run before there are any e-people to authorize!  Since it must be run as a command-line tool on the server machine, generally this shouldn't cause a problem.  A possibility is to have the script only operate when there are no e-people in the system already, though in general, someone with access to command-line scripts on your server is probably in a position to do what they want anyway!</P>

    <P>The <code>DCType</code> class is similar to the <code>org.dspace.content.BitstreamFormat</code> class.  It represents an entry in the Dublin Core type registry, that is, a particular element and qualifier, or unqualified element.  It is in the <code>administer</code> package because it is only generally required when manipulating the registry itself.  Elements and qualifiers are specified as literals in <code>org.dspace.content.Item</code> methods and the <code>org.dspace.content.DCValue</code> class.  Only administrators may modify the Dublin Core type registry.</P>

    <P>The <code>org.dspace.administer.RegistryLoader</code> class contains methods for initialising the Dublin Core type registry and bitstream format registry with entries in an XML file.  Typically this is executed via the command line during the build process (see <code>build.xml</code> in the source.)  To see examples of the XML formats, see the files in <code>config/registries</code> in the source directory.  There is no XML schema, they aren't validated strictly when loaded in.</P>


    <H2><A NAME="eperson">E-person/Group Manager</A></H2>

    <P>DSpace keeps track of registered users with the <code>org.dspace.eperson.EPerson</code> class.  The class has methods to create and manipulate an <code>EPerson</code> such as get and set methods for first and last names, email, and password.  (Actually, there is no <code>getPassword()</code> method--an MD5 hash of the password is stored, and can only be verified with the <code>checkPassword()</code> method.)  There are find methods to find an EPerson by email (which is assumed to be unique,) or to find all EPeople in the system.</P>

    <P>The <code>EPerson</code> object should probably be reworked to allow for easy expansion; the current EPerson object tracks pretty much only what MIT was interested in tracking - first and last names, email, phone.  The access methods are hardcoded and should probably be replaced with methods to access arbitrary name/value pairs for institutions that wish to customize what EPerson information is stored.</P>

    <P>Groups are simply lists of <code>EPerson</code> objects.  Other than membership, <code>Group</code> objects have only one other attribute: a name.  Group names must be unique, so we have adopted naming conventions where the role of the group is its name, such as <code>COLLECTION_100_ADD</code>.  Groups add and remove EPerson objects with <code>addMember()</code> and <code>removeMember()</code> methods.  One important thing to know about groups is that they store their membership in memory until the <code>update()</code> method is called - so when modifying a group's membership don't forget to invoke <code>update()</code> or your changes will be lost!  Since group membership is used heavily by the authorization system a fast <code>isMember()</code> method is also provided.</P>

    <P>Another kind of Group is also implemented in DSpace--special Groups.  The <code>Context</code> object for each session carries around a List of Group IDs that the user is also a member of--currently the MITUser Group ID is added to the list of a user's special groups if certain IP address or certificate criteria are met.</P>


    <H2><A NAME="authorize">Authorization</A></H2>

    <P>The primary classes are:</P>

    <TABLE>
      <TR>
        <TD><code>org.dspace.authorize.AuthorizeManager</code></td>
        <Td>does all authorization, checking policies against Groups</td>
      </TR>
      <TR>
        <TD><code>org.dspace.authorize.ResourcePolicy</code></TD>
        <TD>defines all allowable actions for an object</TD>
      </TR>
      <TR>
        <TD><code>org.dspace.eperson.Group</code></TD>
        <TD>all policies are defined in terms of EPerson Groups</TD>
      </TR>
    </table>

    <P>The authorization system is based on the classic 'police state' model of security; no action is allowed unless it is expressed in a policy.  The policies are attached to resources (hence the name <code>ResourcePolicy</code>,) and detail who can perform that action.  The resource can be any of the DSpace object types, listed in <code>org.dspace.core.Constants</code> (<code>BITSTREAM</code>, <code>ITEM</code>, <code>COLLECTION</code>, etc.)  The 'who' is made up of EPerson groups.  The actions are also in <code>Constants.java</code> (<code>READ</code>, <code>WRITE</code>, <code>ADD</code>, etc.)  The only non-obvious actions are <code>ADD</code> and <code>REMOVE</code>, which are authorizations for container objects.  To be able to create an Item, you must have <code>ADD</code> permission in a Collection, which contains Items.  (Communities, Collections, Items, and Bundles are all container objects.)</P>

    <P>Currently most of the read policy checking is done with items--communities and collections are assumed to be openly readable, but items and their bitstreams are checked.  Separate policy checks for items and their bitstreams enables policies that allow publicly readable items, but parts of their content may be restricted to certain groups.</P>

    <P>The <code>AuthorizeManager</code> class' <code>authorizeAction(Context, object, action)</code> is the primary source of all authorization in the system.  It gets a list of all of the ResourcePolicies in the system that match the object and action.  It then iterates through the policies, extracting the EPerson Group from each policy, and checks to see if the EPersonID from the Context is a member of any of those groups.  If all of the policies are queried and no permission is found, then an <code>AuthorizeException</code> is thrown.  An <code>authorizeAction()</code> method is also supplied that returns a boolean for applications that require higher performance.</P>

    <P>ResourcePolicies are very simple, and there are quite a lot of them.  Each can only list a single group, a single action, and a single object.  So each object will likely have several policies, and if multiple groups share permissions for actions on an object, each group will get its own policy.  (It's a good thing they're small.)</P>


    <H3>Special Groups</H3>

    <P>All users are assumed to be part of the public group (ID=0.)  DSpace admins (ID=1) are automatically part of all groups, much like super-users in the Unix OS.  The Context object also carries around a List of special groups, which are also first checked for membership.  These special groups are used at MIT to indicate membership in the MIT community, something that is very difficult to enumerate in the database!  When a user logs in with an MIT certificate or with an MIT IP address, the login code adds this MIT user group to the user's Context.</P>


    <H3>Miscellaneous Authorization Notes</H3>

    <P>Where do items get their read policies?  From the their collection's read policy.  There once was a separate item read default policy in each collection, and perhaps there will be again since it appears that administrators are notoriously bad at defining collection's read policies.  There is also code in place to enable policies that are timed--have a start and end date.  However, the admin tools to enable these sorts of policies have not been written.</P>


    <H2><A NAME="handle">Handle Manager/Handle Plugin</A></H2>

    <P>The <code>org.dspace.handle</code> package contains two classes; <code>HandleManager</code> is used to create and look up Handles, and <code>HandlePlugin</code> is used to expose and resolve DSpace Handles for the outside world via the CNRI Handle Server code.</P>

    <P>Handles are stored internally in the <code>handle</code> database table in the form:</P>

    <PRE>1721.123/4567</PRE>

    <P>Typically when they are used outside of the system they are displayed in either URI or "URL proxy" forms:</P>

    <PRE>hdl:1721.123/4567
http://hdl.handle.net/1721.123/4567</PRE>

    <P>It is the responsibility of the caller to extract the basic form from whichever displayed form is used.</P>

    <P>The <code>handle</code> table maps these Handles to resource type/resource ID pairs, where resource type is a value from <code>org.dspace.core.Constants</code> and resource ID is the internal identifier (database primary key) of the object.  This allows Handles to be assigned to any type of object in the system, though as <A HREF="functional.html#handles">explained in the functional overview</A>, only communities, collections and items are presently assigned Handles.</P>

    <P><code>HandleManager</code> contains static methods for:</P>

    <UL>
      <LI>Creating a Handle</LI>
      <LI>Finding the Handle for a <code>DSpaceObject</code>, though this is usually only invoked by the object itself, since <code>DSpaceObject</code> has a <code>getHandle</code> method</LI>
      <LI>Retrieving the <code>DSpaceObject</code> identified by a particular Handle</LI>
      <LI>Obtaining displayable forms of the Handle (URI or "proxy URL").</LI>
    </UL>

    <P><code>HandlePlugin</code> is a simple implementation of the Handle Server's <code>net.handle.hdllib.HandleStorage</code> interface.  It only implements the basic Handle retrieval methods, which get information from the <code>handle</code> database table.  The CNRI Handle Server is configured to use this plug-in via its <code>config.dct</code> file.</P>

    <P>Note that since the Handle server runs as a separate JVM to the DSpace Web applications, it uses a separate 'Log4J' configuration, since Log4J does not support multiple JVMs using the same daily rolling logs.  This alternative configuration is held as a template in <code>/dspace/config/templates/log4j-handle-plugin.properties</code>, written to <code>/dspace/config/log4j-handle-plugin.properties</code> by the <code>install-configs</code> script.  The <code>/dspace/bin/start-handle-server</code> script passes in the appropriate command line parameters so that the Handle server uses this configuration.</P>


    <H2><A NAME="search">Search</A></H2>

    <P>DSpace's search code is a simple API which currently wraps the Lucene search engine. The first half of the search task is indexing, and <code>org.dspace.search.DSIndexer</code> is the indexing class, which contains <code>indexContent()</code> which if passed an <code>Item</code>, <code>Community</code>, or <code>Collection</code>, will add that content's fields to the index.  The methods <code>unIndexContent()</code> and <code>reIndexContent()</code> remove and update content's index information.  The <code>DSIndexer</code> class also has a <code>main()</code> method which will rebuild the index completely.  This is invoked by the <code>dspace/bin/index-all</code> script.  The intent was for the <code>main()</code> method to be invoked on a regular basis to avoid index corruption, but we have had no problem with that so far.</P>
    
    <p> Which fields are indexed by <code>DSIndexer</code>? These fields are defined in dspace.cfg in the section "Fields to index for search" as name-value-pairs. The name must be unique in the form search.index.i (i is an arbitrary positive number). The value on the right side has a unique value again, which can be referenced in search-form (e.g. title, author). Then comes the metadata element which is indexed. '*' is a wildcard which includes all subelements. For example:</p>

    <p><code>search.index.4 = keyword:dc.subject.*</code></p>

    <p>tells the indexer to create a keyword index containing all dc.subject element values. Since the wildcard ('*') character was used in place of a qualifier, all subject metadata fields will be indexed (e.g. dc.subject.other, dc.subject.lcsh, etc)</p>

    <p>By default, the fields shown in the <code>Indexed Fields</code> section below are indexed. These are hardcoded in the DSIndexer class. If any search.index.i items are specified in <code>dspace.cfg</code> these are used rather than these hardcoded fields.</p>

    <P>The query class <code>DSQuery</code> contains the three flavors of <code>doQuery()</code> methods--one searches the DSpace site, and the other two restrict searches to Collections and Communities.  The results from a query are returned as three lists of handles; each list represents a type of result.  One list is a list of Items with matches, and the other two are Collections and Communities that match.  This separation allows the UI to handle the types of results gracefully without resolving all of the handles first to see what kind of content the handle points to.  The <code>DSQuery</code> class also has a <code>main()</code> method for debugging via command-line searches.</P>

    <H3>Our Lucene Implementation</H3>

    <P>Currently we have our own Analyzer and Tokenizer classes (<code>DSAnalyzer</code> and <code>DSTokenizer</code>) to customize our indexing.  They invoke the stemming and stop word features within Lucene.  We create an <code>IndexReader</code> for each query, which we now realize isn't the most efficient use of resources - we seem to run out of filehandles on really heavy loads.  (A wildcard query can open many filehandles!)  Since Lucene is thread-safe, a better future implementation would be to have a single Lucene IndexReader shared by all queries, and then is invalidated and re-opened when the index changes.  Future API growth could include relevance scores (Lucene generates them, but we ignore them,) and abstractions for more advanced search concepts such as booleans.</P>

    <H3>Indexed Fields</H3>

    <P>The <code>DSIndexer</code> class shipped with DSpace indexes the Dublin Core metadata in the following way:</P>

    <TABLE>
      <TR>
        <TH>Search Field</TH>
        <TH>Taken from Dublin Core Fields</TH>
      </TR>

      <TR>
        <TD>Authors</TD>
        <TD><code>contributor.*</code><br>
        <code>creator.*</code><br>
        <code>description.statementofresponsibility</code></TD>
      </TR>

      <TR>
        <TD>Titles</TD>
        <TD><CODE>title.*</code></td>
      </tr>

      <tr>
        <td>Keywords</tD>
        <td><code>subject.*</code>
      </tr>

      <tr>
        <td>Abstracts</td>
        <td><code>description.abstract</code><br>
        <code>description.tableofcontents</code></td>
      </tr>

      <tr>
        <td>Series</td>
        <td><code>relation.ispartofseries</code></td>
      </tr>

      <tr>
        <td>MIME types</td>
        <td><code>format.mimetype</code></td>
      </tr>

      <tr>
        <td>Sponsors</td>
        <td><code>description.sponsorship</code></td>
      </tr>

      <tr>
        <td>Identifiers</td>
        <td><code>identifier.*</code></td>
      </tr>
    </table>



    <H3>Harvesting API</H3>

    <P>The <code>org.dspace.search</code> package also provides a 'harvesting' API.  This allows callers to extract information about items modified within a particular timeframe, and within a particular scope (all of DSpace, or a community or collection.)  Currently this is used by the Open Archives Initiative metadata harvesting protocol application, and the e-mail subscription code.</P>

    <P>The <code>Harvest.harvest</code> is invoked with the required scope and start and end dates.  Either date can be omitted.  The dates should be in the ISO8601, UTC time zone format used elsewhere in the DSpace system.</P>

    <P><code>HarvestedItemInfo</code> objects are returned.  These objects are simple containers with basic information about the items falling within the given scope and date range.  Depending on parameters passed to the <code>harvest</code> method, the <code>containers</code> and <code>item</code> fields may have been filled out with the IDs of communities and collections containing an item, and the corresponding <code>Item</code> object respectively.  Electing not to have these fields filled out means the harvest operation executes considerable faster.</P>

    <P>In case it is required, <code>Harvest</code> also offers a method for creating a single <code>HarvestedItemInfo</code> object, which might make things easier for the caller.</P>


    <H2><A NAME="browse">Browse API</A></H2>

    <P>The browse API maintains indices of dates, authors, titles and subjects, and allows callers to extract parts of these:</P>

    <DL>
      <DT>Title</DT>

      <DD><P>Values of the Dublin Core element <strong><code>title</code></strong> (unqualified) are indexed.  These are sorted in a case-insensitive fashion, with any leading article removed. For example:</P>

      <PRE>The DSpace System</PRE>

      <P>Appears under 'D' rather than 'T'.</P></DD>

      <DT>Author</DT>

      <DD><P>Values of the <strong><code>contributor</code></strong> (any qualifier or unqualified) element are indexed.  Since <code>contributor</code> values typically are in the form 'last name, first name', a simple case-insensitive alphanumeric sort is used which orders authors in last name order.</P>

      <P>Note that this is an index of <em>authors</em>, and not <em>items by author</em>.  If four items have the same author, that author will appear in the index only once.  Hence, the index of authors may be greater or smaller than the index of titles; items often have more than one author, though the same author may have authored several items.</P>

      <P>The author indexing in the browse API does have limitations:</P>

      <UL>
        <LI><P>Ideally, a name that appears as an author for more than one item would appear in the author index only once.  For example, 'Doe, John' may be the author of tens of items.  However, in practice, author's names often appear in slightly differently forms, for example:</P>

        <PRE>Doe, John
Doe, John Stewart
Doe, John S.</PRE>

        <P>Currently, the above three names would all appear as separate entries in the author index even though they may refer to the same author.  In order for an author of several papers to be correctly appear once in the index, each item must specify <em>exactly</em> the same form of their name, which doesn't always happen in practice.</P></LI>

        <LI><P>Another issue is that two authors may have the same name, even within a single institution.  If this is the case they may appear as one author in the index.</P></LI>
      </UL>

      <P>These issues are typically resolved in libraries with <em>authority control records</em>, in which are kept a 'preferred' form of the author's name, with extra information (such as date of birth/death) in order to distinguish between authors of the same name.  Maintaining such records is a huge task with many issues, particularly when metadata is received from faculty directly rather than trained library cataloguers.  For these reasons, DSpace does not yet feature 'authority control' functionality.</P></DD>

      <DT>Date of Issue</DT>

      <DD><P>Items are indexed by date of issue.  This may be different from the date that an item appeared in DSpace; many items may have been originally published elsewhere beforehand.  The Dublin Core field used is <strong><code>date.issued</code></strong>.  The ordering of this index may be reversed so 'earliest first' and 'most recent first' orderings are possible.</P>

      <P>Note that the index is of <em>items by date</em>, as opposed to an index of <em>dates</em>.  If 30 items have the same issue date (say 2002), then those 30 items all appear in the index adjacent to each other, as opposed to a single 2002 entry.</P>

      <P>Since dates in DSpace Dublin Core are in ISO8601, all in the UTC time zone, a simple alphanumeric sort is sufficient to sort by date, including dealing with varying granularities of date reasonably.  For example:</P>

      <PRE>2001-12-10
2002
2002-04
2002-04-05
2002-04-09T15:34:12Z
2002-04-09T19:21:12Z
2002-04-10</PRE></DD>

      <DT>Date Accessioned</DT>

      <DD><P>In order to determine which items most recently appeared, rather than using the date of issue, an item's accession date is used.  This is the Dublin Core field <strong><code>date.accessioned</code></strong>.  In other aspects this index is identical to the date of issue index.</P></DD>


      <DT>Items by a Particular Author</DT>

      <DD><P>The browse API can perform is to extract items by a particular author.  They do not have to be primary author of an item for that item to be extracted.  You can specify a scope, too; that is, you can ask for items by author X in collection Y, for example.</P>

      <P>This particular flavour of browse is slightly simpler than the others.  You cannot presently specify a particular subset of results to be returned.  The API call will simply return all of the items by a particular author within a certain scope.</P>

      <P>Note that the author of the item must <em>exactly</em> match the author passed in to the API; see the explanation about the caveats of the author index browsing to see why this is the case.</P></DD>

	<dt>Subject</dt>
	
     <dd><p>Values of the Dublin Core element <strong><code>subject</code></strong> (both unqualified and with any qualifier) are indexed.  These are sorted in a case-insensitive fashion.</p></dd>
    </DL>

    <h3>Using the API</h3>

    <P>The API is generally invoked by creating a <code>BrowseScope</code> object, and setting the parameters for which particular part of an index you want to extract.  This is then passed to the relevent <code>Browse</code> method call, which returns a <code>BrowseInfo</code> object which contains the results of the operation.  The parameters set in the <code>BrowseScope</code> object are:</P>

    <UL>
      <LI>How many entries from the index you want</LI>
      <LI>Whether you only want entries from a particular community or collection, or from the whole of DSpace</LI>
      <LI>Which part of the index to start from (called the <em>focus</em> of the browse).  If you don't specify this, the start of the index is used</LI>
      <LI>How many entries to include before the <em>focus</em> entry</LI>
    </UL>

    <P>To illustrate, here is an example:</P>

    <UL>
      <LI>We want <strong>7</strong> entries in total</LI>
      <LI>We want entries from collection <em>x</em></LI>
      <LI>We want the focus to be 'Really'</LI>
      <LI>We want <strong>2</strong> entries included before the focus.</LI>
    </UL>

    <P>The results of invoking <code>Browse.getItemsByTitle</code> with the above parameters might look like this:</P>

    <PRE>        Rabble-Rousing Rabbis From Sardinia
        Reality TV: Love It or Hate It?
FOCUS>  The Really Exciting Research Video
        Recreational Housework Addicts: Please Visit My House
        Regional Television Variation Studies
        Revenue Streams
        Ridiculous Example Titles:  I'm Out of Ideas</PRE>

    <P>Note that in the case of title and date browses, <code>Item</code> objects are returned as opposed to actual titles.  In these cases, you can specify the 'focus' to be a specific item, or a partial or full literal value.  In the case of a literal value, if no entry in the index matches exactly, the closest match is used as the focus.  It's quite reasonable to specify a focus of a single letter, for example.</P>

    <P>Being able to specify a specific item to start at is particularly important with dates, since many items may have the save issue date.  Say 30 items in a collection have the issue date 2002.  To be able to page through the index 20 items at a time, you need to be able to specify exactly which item's 2002 is the focus of the browse, otherwise each time you invoked the browse code, the results would start at the first item with the issue date 2002.</P>

    <P>Author browses return <code>String</code> objects with the actual author names.  You can only specify the focus as a full or partial literal <code>String</code>.</P>

    <P>Another important point to note is that presently, the browse indices contain metadata for all items in the main archive, regardless of authorization policies.  This means that all items in the archive will appear to all users when browsing.  Of course, should the user attempt to access a non-public item, the usual authorization mechanism will apply.  Whether this approach is ideal is under review; implementing the browse API such that the results retrieved reflect a user's level of authorization may be possible, but rather tricky.</P>


    <H3>Index Maintenance</H3>

    <P>The browse API contains calls to add and remove items from the index, and to regenerate the indices from scratch.  In general the content management API invokes the necessary browse API calls to keep the browse indices in sync with what is in the archive, so most applications will not need to invoke those methods.</P>

    <P>If the browse index becomes inconsistent for some reason, the <code>InitializeBrowse</code> class is a command line tool (generally invoked using the <code>/dspace/bin/index-all</code> shell script) that causes the indices to be regenerated from scratch.</P>


    <H3>Caveats</H3>

    <P>Presently, the browse API is not tremendously efficient.  'Indexing' takes the form of simply extracting the relevant Dublin Core value, normalising it (lower-casing and removing any leading article in the case of titles), and inserting that normalized value with the corresponding item ID in the appropriate browse database table.  Database views of this table include collection and community IDs for browse operations with a limited scope.  When a browse operation is performed, a simple <code>SELECT</code> query is performed, along the lines of:</P>

    <PRE>SELECT item_id FROM ItemsByTitle ORDER BY sort_title OFFSET 40 LIMIT 20</PRE>

    <P>There are two main drawbacks to this:  Firstly, <code>LIMIT</code> and <code>OFFSET</code> are PostgreSQL-specific keywords.  Secondly, the database is still actually performing dynamic sorting of the titles, so the browse code as it stands will not scale particularly well.  The code does cache <code>BrowseInfo</code> objects, so that common browse operations are performed quickly, but this is not an ideal solution.</P>


    <H2><A NAME="history">History Recorder</A></H2>

    <P>The purpose of the history subsystem is to capture a time-based record of significant changes in DSpace, in a manner suitable for later refactoring or repurposing.  Note that the history data is not expected to provide current information about the archive; it simply records what has happened in the past.</P>

    <P>The <A HREF="http://www.metadata.net/harmony/">Harmony project</A> describes a simple and powerful approach for modeling temporal data.  The DSpace history framework adopts this model.  The Harmony model is used by the serialization mechanism (and ultimately by agents who interpret the serializations); users of the History API need not be aware of it.  The content management API handles invocations of the history system.  Users of the DSpace public API do not generally need to use the history API.</P>

    <P>When anything of archival interest occurs in DSpace, the <code>saveHistory</code> method of the <code>HistoryManager</code> is invoked. The parameters contains a reference to anything of archival interest.  Upon reception of the object, it serializes the state of all archive objects referred to by it, and creates Harmony-style objects and associations to describe the relationships between the objects. (A simple example is given below). Note that each archive object must have a unique identifier to allow linkage between discrete events; this is discussed under "Unique IDs" below.</P>

    <P>The serializations (including the Harmony objects and associations) are persisted as files in the <code>/dspace/history</code> (or other configured) directory.  The <code>history</code> and <code>historystate</code> tables contain simple indicies into the serializations in the file system.</P>

    <H3>Archival Events</H3>

    <P>The following events are significant enough to warrant history records:</P>

    <UL>
      <LI>Communities
        <UL>
          <LI>create/modify/delete</LI>
          <LI>add/remove Collection to/from Community</LI>
        </UL>
      </LI>
      <LI>Collections
        <UL>
          <LI>create/modify/delete</LI>
          <LI>add/remove Item to/from Collection</LI>
        </UL>
      </LI>
      <LI>Items
        <UL>
          <LI>create/modify/delete</LI>
          <LI>assign Handle to Item</LI>
          <LI>modify Item contents (Bundles, Bitstreams, metadata fields, etc)</LI>
        </UL>
      </LI>
      <LI>EPerson
        <UL>
          <LI>create/modify/delete</LI>
        </UL>
      </LI>
      <LI>Workflow
        <UL>
          <LI>Workflow completed</LI>
        </UL>
      </LI>
    </UL>


    <H3>Serializations</H3>

    <P>The serialization of an archival object consists of:</P>

    <UL>
      <LI>Its instance fields (ie, non-static, non-transient fields)</LI>
      <LI>The serializations of associated objects (or references to these serializations).</LI>
    </UL>


    <H3>Unique Ids</H3>

    <P>To be able to trace the history of an object, it is essential that the object have a unique identifier.  Since not all objects in the system have Handles, the unique identifiers are only weakly tied to the Handle system. Instead, the identifier consists of:</P>

    <UL>
      <LI>an identifer for the project</LI>
      <LI>a site id (using the handle prefix)</LI>
      <LI>an RDBMS-based id for objects</LI>
    </UL>


    <H3>Storage</H3>

    <P>When an archive object is serialized, an object ID and MD5 checksum are recorded. When another object is serialized, the checksum for the serialization is matched against existing checksums for that object. If the checksum already exists, the object is not stored; a reference to the object is used instead.  Note that since none of the serializations are deleted, reference counting is unnecessary.</P>

    <P>The history data is not initially stored in a queryable form.  Two simple RDBMS tables give basic indications of what is stored, and where.  The <code>history</code> table is an index of serializations with checksums and dates.  The <code>history_id</code> column corresponds to the file in which a serialization is stored.  For example, if the history ID is 123456, it will be stored in the file:</P>

    <PRE>/dspace/history/00/12/34/123456</PRE>

    <P>The table also contains the date the serialization was written and the MD5 checksum of the serialization.</P>

    <P>The <code>historystate</code> table is supposed to indicate the most recent serialization of any given object.</P>


    <H3>Example</H3>

    <P>An item is submitted to a collection via bulk upload. When (and if) the item is eventually added to the collection, the history method is called, with references to the item, its collection, the e-person who performed the bulk upload, and some indication of the fact that it was submitted via a bulk upload.</P>

    <P>When called, the HistoryManager does the following:  It creates the following new resources (all with unique ids):</P>

    <UL>
      <LI>An event</LI>
      <LI>A state</LI>
      <LI>An action</LI>
    </UL>

    <P>It also generates the following relationships:</P>

    <PRE>event  --atTime-->     time
event  --hasOutput-->  state
Item   --inState-->    state
state  --contains-->   Item
action --creates-->    Item
event  --hasAction-->  action
action --usesTool-->   DSpace Upload
action --hasAgent-->   User</PRE>

    <P>The history component serializes the state of all archival objects involved (in this case, the item, the e-person, and the collection). It creates entries in the history database tables which associate the archival objects with the generated serializations.</P>

    <H3>Caveats</H3>

    <P>This history system is a largely untested experiment.  It also needs further documentation.  There have been no serious efforts to determine whether the information written by the history system, either to files or the database tables, is accurate.  In particular, the <code>historystate</code> table does not seem to be correctly written.</P>

    <h2><a name="checker">Checksum checker</a></h2>
    <p>The architecture of the checker is documented in the package javadocs, run <code>ant public_api</code>, and look in <code>build/public_api/index.html</code>.</p>
    <HR>

    <ADDRESS>
     Copyright &copy; 2002-2008 The DSpace Foundation
    </ADDRESS>
  </BODY>
</HTML>
