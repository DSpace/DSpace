h1. DSpace System Documentation: Business Logic Layer(_ConfigurationManager_)h2. Core ClassesThe _org.dspace.core_ package provides some basic classes that are used throughout the DSpace code.h3. The Configuration Manager (_ConfigurationManager_)The configuration manager is responsible for reading the main _dspace.cfg_ properties file, managing the 'template' configuration files for other applications such as Apache, and for obtaining the text for e-mail messages.The system is configured by editing the relevant files in _/dspace/config_, as described in the configuration section.*When editing configuration files for applications that DSpace uses, such as Apache, remember to edit the file in /dspace/config/templates and then run /dspace/bin/install-configs rather than editing the 'live' version directly!*The _ConfigurationManager_ class can also be invoked as a command line tool, with two possible uses:* _/dspace/bin/install-configs_This processes and installs configuration files for other applications, as described in the configuration section.* _/dspace/bin/dsrun org.dspace.core.ConfigurationManager -property property.name_This writes the value of _property.name_ from _dspace.cfg_ to the standard output, so that shell scripts can access the DSpace configuration. For an example, see _/dspace/bin/start-handle-server_. If the property has no value, nothing is written.h3. ConstantsThis class contains constants that are used to represent types of object and actions in the database. For example, authorization policies can relate to objects of different types, so the _resourcepolicy_ table has columns _resource_id_, which is the internal ID of the object, and _resource_type_id_, which indicates whether the object is an item, collection, bitstream etc. The value of _resource_type_id_ is taken from the _Constants_ class, for example _Constants.ITEM_.h3. ContextThe _Context_ class is central to the DSpace operation. Any code that wishes to use the any API in the business logic layer must first create itself a _Context_ object. This is akin to opening a connection to a database (which is in fact one of the things that happens.)A context object is involved in most method calls and object constructors, so that the method or object has access to information about the current operation. When the context object is constructed, the following information is automatically initialized:*  A connection to the database. This is a transaction-safe connection. i.e. the 'auto-commit' flag is set to false. *  A cache of content management API objects. Each time a content object is created (for example _Item_ or _Bitstream_) it is stored in the _Context_ object. If the object is then requested again, the cached copy is used. Apart from reducing database use, this addresses the problem of having two copies of the same object in memory in different states.The following information is also held in a context object, though it is the responsiblity of the application creating the context object to fill it out correctly:*  The current authenticated user, if any *  Any 'special groups' the user is a member of. For example, a user might automatically be part of a particular group based on the IP address they are accessing DSpace from, even though they don't have an e-person record. Such a group is called a 'special group'. *  Any extra information from the application layer that should be added to log messages that are written within this context. For example, the Web UI adds a session ID, so that when the logs are analysed the actions of a particular user in a particular session can be tracked. *  A flag indicating whether authorization should be circumvented. This should only be used in rare, specific circumstances. For example, when first installing the system, there are no authorized administrators who would be able to create an administrator account! As noted above, the public API is _trusted_, so it is up to applications in the application layer to use this flag responsibly.Typical use of the context object will involve constructing one, and setting the current user if one is authenticated. Several operations may be performed using the context object. If all goes well, _complete_ is called to commit the changes and free up any resources used by the context. If anything has gone wrong, _abort_ is called to roll back any changes and free up the resources.You should always _abort_ a context if _any_ error happens during its lifespan; otherwise the data in the system may be left in an inconsistent state. You can also _commit_ a context, which means that any changes are written to the database, and the context is kept active for further use.h3. EmailSending e-mails is pretty easy. Just use the configuration manager's _getEmail_ method, set the arguments and recipients, and send.The e-mail texts are stored in _/dspace/config/emails_. They are processed by the standard _java.text.MessageFormat_. At the top of each e-mail are listed the appropriate arguments that should be filled out by the sender. Example usage is shown in the _org.dspace.core.Email_ Javadoc API documentation.h3. LogManagerThe log manager consists of a method that creates a standard log header, and returns it as a string suitable for logging. Note that this class does not actually write anything to the logs; the log header returned should be logged directly by the sender using an appropriate Log4J call, so that information about where the logging is taking place is also stored.The level of logging can be configured on a per-package or per-class basis by editing _/dspace/config/templates/log4j.properties_ and then executing _/dspace/bin/install-configs_. You will need to stop and restart Tomcat for the changes to take effect.A typical log entry looks like this:_2002-11-11 08:11:32,903 INFO org.dspace.app.webui.servlet.DSpaceServlet @ anonymous:session_id=BD84E7C194C2CF4BD0EC3A6CAD0142BB:view_item:handle=1721.1/1686_This is breaks down like this:|Date and time, milliseconds |_2002-11-11 08:11:32,903_||Level (_FATAL_, _WARN_, _INFO_ or _DEBUG_)|_INFO_||Java class |_org.dspace.app.webui.servlet.DSpaceServlet_|| |_@_||User email or _anonymous_|_anonymous_|| |_:_||Extra log info from context |_session_id=BD84E7C194C2CF4BD0EC3A6CAD0142BB_|| |_:_||Action |_view_item_|| |_:_||Extra info |_handle=1721.1/1686_|The above format allows the logs to be easily parsed and analysed. The _/dspace/bin/log-reporter_ script is a simple tool for analysing logs. Try:_/dspace/bin/log-reporter --help_It's a good idea to 'nice' this log reporter to avoid an impact on server performance.h3. Utils_Utils_ comtains miscellaneous utility method that are required in a variety of places throughout the code, and thus have no particular 'home' in a subsystem.h2. Content Management APIThe content management API package _org.dspace.content_ contains Java classes for reading and manipulating content stored in the DSpace system. This is the API that components in the application layer will probably use most.Classes corresponding to the main elements in the DSpace data model (_Community_, _Collection_, _Item_, _Bundle_ and _Bitstream_) are sub-classes of the abstract class _DSpaceObject_. The _Item_ object handles the Dublin Core metadata record.Each class generally has one or more static _find_ methods, which are used to instantiate content objects. Constructors do not have public access and are just used internally. The reasons for this are:*  "Constructing" an object may be misconstrued as the action of creating an object in the DSpace system, for example one might expect something like: {code}Context dsContent = new Context();
Item myItem = new Item(context, id){code}to construct a brand new item in the system, rather than simply instantiating an in-memory instance of an object in the system. * _find_ methods may often be called with invalid IDs, and return _null_ in such a case. A constructor would have to throw an exception in this case. A _null_ return value from a static method can in general be dealt with more simply in code.*  If an instantiation representing the same underlying archival entity already exists, the _find_ method can simply return that same instantiation to avoid multiple copies and any inconsistencies which might result._Collection_, _Bundle_ and _Bitstream_ do not have _create_ methods; rather, one has to create an object using the relevant method on the container. For example, to create a collection, one must invoke _createCollection_ on the community that the collection is to appear in:{code}Context context = new Context();
Community existingCommunity = Community.find(context, 123);
Collection myNewCollection = existingCommunity.createCollection();{code}The primary reason for this is for determining authorization. In order to know whether an e-person may create an object, the system must know which container the object is to be added to. It makes no sense to create a collection outside of a community, and the authorization system does not have a policy for that._Item_s are first created in the form of an implementation of _InProgressSubmission_. An _InProgressSubmission_ represents an item under construction; once it is complete, it is installed into the main archive and added to the relevant collection by the _InstallItem_ class. The _org.dspace.content_ package provides an implementation of _InProgressSubmission_ called _WorkspaceItem_; this is a simple implementation that contains some fields used by the Web submission UI. The _org.dspace.workflow_ also contains an implementation called _WorkflowItem_ which represents a submission undergoing a workflow process.In the previous chapter there is an overview of the item ingest process which should clarify the previous paragraph. Also see the section on the workflow system._Community_ and _BitstreamFormat_ do have static _create_ methods; one must be a site administrator to have authorization to invoke these.h3. Other ClassesClasses whose name begins _DC_ are for manipulating Dublin Core metadata, as explained below.The _FormatIdentifier_ class attempts to guess the bitstream format of a particular bitstream. Presently, it does this simply by looking at any file extension in the bitstream name and matching it up with the file extensions associated with bitstream formats. Hopefully this can be greatly improved in the future!The _ItemIterator_ class allows items to be retrieved from storage one at a time, and is returned by methods that may return a large number of items, more than would be desirable to have in memory at once.The _ItemComparator_ class is an implementation of the standard _java.util.Comparator_ that can be used to compare and order items based on a particular Dublin Core metadata field.h3. ModificationsWhen creating, modifying or for whatever reason removing data with the content management API, it is important to know when changes happen in-memory, and when they occur in the physical DSpace storage.Primarily, one should note that no change made using a particular _org.dspace.core.Context_ object will actually be made in the underlying storage unless _complete_ or _commit_ is invoked on that _Context_. If anything should go wrong during an operation, the context should always be aborted by invoking _abort_, to ensure that no inconsistent state is written to the storage.Additionally, some changes made to objects only happen in-memory. In these cases, invoking the _update_ method lines up the in-memory changes to occur in storage when the _Context_ is committed or completed. In general, methods that change any \[meta\]data field only make the change in-memory; methods that involve relationships with other objects in the system line up the changes to be committed with the context. See individual methods in the API Javadoc.Some examples to illustrate this are shown below:|{code}Context context = new Context();
Bitstream b = Bitstream.find(context, 1234);
b.setName("newfile.txt");
b.update();
context.complete();{code}|*Will* change storage||{code}Context context = new Context();
Bitstream b = Bitstream.find(context, 1234);
b.setName("newfile.txt");
b.update();
context.abort();{code}|*Will not* change storage (context aborted)||{code}Context context = new Context();
Bitstream b = Bitstream.find(context, 1234);
b.setName("newfile.txt");
context.complete();{code}|The new name *will not* be stored since _update_ was not invoked||{code}Context context = new Context();
Bitstream bs = Bitstream.find(context, 1234);
Bundle bnd = Bundle.find(context, 5678);
bnd.add(bs);
context.complete();{code}|The bitstream *will* be included in the bundle, since _update_ doesn't need to be called|h3. What's In Memory?Instantiating some content objects also causes other content objects to be loaded into memory.Instantiating a _Bitstream_ object causes the appropriate _BitstreamFormat_ object to be instantiated. Of course the _Bitstream_ object does not load the underlying bits from the bitstream store into memory!Instantiating a _Bundle_ object causes the appropriate _Bitstream_ objects (and hence _BitstreamFormat_s) to be instantiated.Instantiating an _Item_ object causes the appropriate _Bundle_ objects (etc.) and hence _BitstreamFormat_s to be instantiated. All the Dublin Core metadata associated with that item are also loaded into memory.The reasoning behind this is that for the vast majority of cases, anyone instantiating an item object is going to need information about the bundles and bitstreams within it, and this methodology allows that to be done in the most efficient way and is simple for the caller. For example, in the Web UI, the servlet (controller) needs to pass information about an item to the viewer (JSP), which needs to have all the information in-memory to display the item without further accesses to the database which may cause errors mid-display.You do not need to worry about multiple in-memory instantiations of the same object, or any inconsistenties that may result; the _Context_ object keeps a cache of the instantiated objects. The _find_ methods of classes in _org.dspace.content_ will use a cached object if one exists.It may be that in enough cases this automatic instantiation of contained objects reduces performance in situations where it is important; if this proves to be true the API may be changed in the future to include a _loadContents_ method or somesuch, or perhaps a Boolean parameter indicating what to do will be added to the _find_ methods.When a _Context_ object is completed, aborted or garbage-collected, any objects instantiated using that context are invalidated and should not be used (in much the same way an AWT button is invalid if the window containing it is destroyed).h3. Dublin Core MetadataThe _DCValue_ class is a simple container that represents a single Dublin Core element, optional qualifier, value and language. Note that since DSpace 1.4 the _MetadataValue_ and associated classes are preferred (see Support for Other Metadata Schemas). The other classes starting with _DC_ are utility classes for handling types of data in Dublin Core, such as people's names and dates. As supplied, the DSpace registry of elements and qualifiers corresponds to the [Library Application Profile|http://www.dublincore.org/documents/2002/09/24/library-application-profile/|Library Application Profile] for Dublin Core. It should be noted that these utility classes assume that the values will be in a certain syntax, which will be true for all data generated within the DSpace system, but since Dublin Core does not always define strict syntax, this may not be true for Dublin Core originating outside DSpace.Below is the specific syntax that DSpace expects various fields to adhere to:|*Element*|*Qualifier*|*Syntax*|*Helper Class*||_date_|Any or unqualified |ISO 8601 in the UTC time zone, with either year, month, day, or second precision. Examples: _2000 2002-10 2002-08-14 1999-01-01T14:35:23Z _|_DCDate_||_contributor_|Any or unqualified |In general last name, then a comma, then first names, then any additional information like "Jr.". If the contributor is an organization, then simply the name. Examples: _Doe, John Smith, John Jr. van Dyke, Dick Massachusetts Institute of Technology _|_DCPersonName_||_language_|_iso_|A two letter code taken ISO 639, followed optionally by a two letter country code taken from ISO 3166. Examples: _en fr en_US _|_DCLanguage_||_relation_|_ispartofseries_|The series name, following by a semicolon followed by the number in that series. Alternatively, just free text. _MIT-TR; 1234 My Report Series; ABC-1234 NS1234 _|_DCSeriesNumber_|h3. Support for Other Metadata SchemasTo support additional metadata schemas a new set of metadata classes have been added. These are backwards compatible with the DC classes and should be used rather than the DC specific classes whereever possible. Note that hierarchical metadata schemas are not currently supported, only flat schemas (such as DC) are able to be defined.The _MetadataField_ class describes a metadata field by schema, element and optional qualifier. The value of a _MetadataField_ is described by a _MetadataValue_ which is roughly equivalent to the older _DCValue_ class. Finally the _MetadataSchema_ class is used to describe supported schemas. The DC schema is supported by default. Refer to the javadoc for method details.h3. Packager PluginsThe Packager plugins let you _ingest_ a package to create a new DSpace Object, and _disseminate_ a content Object as a package. A package is simply a data stream; its contents are defined by the packager plugin's implementation.To ingest an object, which is currently only implemented for Items, the sequence of operations is:#  Get an instance of the chosen _PackageIngester_ plugin.#  Locate a Collection in which to create the new Item. #  Call its _ingest_ method, and get back a _WorkspaceItem_.The packager also takes a _PackageParameters_ object, which is a property list of parameters specific to that packager which might be passed in from the user interface.Here is an example package ingestion code fragment:{code}Collection collection =  find target collection
     InputStream source = ...;
     PackageParameters params = ...;
     String license = null;

    PackageIngester sip = (PackageIngester) PluginManager
            .getNamedPlugin(PackageIngester.class, packageType);

    WorkspaceItem wi = sip.ingest(context, collection, source, params, license);{code}Here is an example of a package dissemination:{code}     OutputStream destination = ...;
     PackageParameters params = ...;
     DSpaceObject dso = ...;

     PackageIngester dip = (PackageDisseminator) PluginManager
             .getNamedPlugin(PackageDisseminator.class, packageType);

     dip.disseminate(context, dso, params, destination);{code}h2. Plugin ManagerThe PluginManager is a very simple component container. It creates and organizes components (plugins), and helps select a plugin in the cases where there are many possible choices. It also gives some limited control over the lifecycle of a plugin.h3. ConceptsThe following terms are important in understanding the rest of this section:* *Plugin Interface* A Java interface, the defining characteristic of a plugin. The consumer of a plugin asks for its plugin by interface.* *Plugin* a.k.a. Component, this is an instance of a class that implements a certain interface. It is interchangeable with other implementations, so that any of them may be "plugged in", hence the name. A Plugin is an instance of any class that implements the plugin interface.* *Implementation class* The actual class of a plugin. It may implement several plugin interfaces, but must implement at least one.* *Name* Plugin implementations can be distinguished from each other by name, a short String meant to symbolically represent the implementation class. They are called "named plugins". Plugins only need to be named when the caller has to make an active choice between them.* *SelfNamedPlugin class* Plugins that extend the _SelfNamedPlugin_ class can take advantage of additional features of the Plugin Manager. Any class can be managed as a plugin, so it is not necessary, just possible.* *Reusable* Reusable plugins are only instantiated once, and the Plugin Manager returns the same (cached) instance whenever that same plugin is requested again. This behavior can be turned off if desired.h3. Using the Plugin Managerh4. Types of PluginThe Plugin Manager supports three different patterns of usage:# *Singleton Plugins* There is only one implementation class for the plugin. It is indicated in the configuration. This type of plugin chooses an implementation of a service, for the entire system, at configuration time. Your application just fetches the plugin for that interface and gets the configured-in choice. See the getSinglePlugin() method.# *Sequence Plugins* You need a sequence or series of plugins, to implement a mechanism like Stackable Authentication or a pipeline, where each plugin is called in order to contribute its implementation of a process to the whole. The Plugin Manager supports this by letting you configure a sequence of plugins for a given interface. See the getPluginSequence() method.# *Named Plugins* Use a named plugin when the application has to choose one plugin implementation out of many available ones. Each implementation is bound to one or more names (symbolic identifiers) in the configuration.The name is just a string to be associated with the combination of implementation class and interface. It may contain any characters except for comma (,) and equals (=). It may contain embedded spaces. Comma is a special character used to separate names in the configuration entry. Names must be unique within an interface: No plugin classes implementing the same interface may have the same name. Think of plugin names as a controlled vocabulary -- for a given plugin interface, there is a set of names for which plugins can be found. The designer of a Named Plugin interface is responsible for deciding what the name means and how to derive it; for example, names of metadata crosswalk plugins may describe the target metadata format. See the getNamedPlugin() method and the getPluginNames() methods.h4. Self-Named PluginsNamed plugins can get their names either from the configuration or, for a variant called self-named plugins, from within the plugin itself.Self-named plugins are necessary because one plugin implementation can be configured itself to take on many "personalities", each of which deserves its own plugin name. It is already managing its own configuration for each of these personalities, so it makes sense to allow it to export them to the Plugin Manager rather than expecting the plugin configuration to be kept in sync with it own configuration.An example helps clarify the point: There is a named plugin that does crosswalks, call it _CrosswalkPlugin_. It has several implementations that crosswalk some kind of metadata. Now we add a new plugin which uses XSL stylesheet transformation (XSLT) to crosswalk many types of metadata -- so the single plugin can act like many different plugins, depending on which stylesheet it employs.This XSLT-crosswalk plugin has its own configuration that maps a Plugin Name to a stylesheet -- it has to, since of course the Plugin Manager doesn't know anything about stylesheets. It becomes a self-named plugin, so that it reads its configuration data, gets the list of names to which it can respond, and passes those on to the Plugin Manager.When the Plugin Manager creates an instance of the XSLT-crosswalk, it records the Plugin Name that was responsible for that instance. The plugin can look at that Name later in order to configure itself correctly for the Name that created it. This mechanism is all part of the SelfNamedPlugin class which is part of any self-named plugin.h4. Obtaining a Plugin InstanceThe most common thing you will do with the Plugin Manager is obtain an instance of a plugin. To request a plugin, you must always specify the plugin interface you want. You will also supply a name when asking for a named plugin.A sequence plugin is returned as an array of _Object_s since it is actually an ordered list of plugins.See the getSinglePlugin(), getPluginSequence(), getNamedPlugin() methods.h4. Lifecycle ManagementWhen _PluginManager_ fulfills a request for a plugin, it checks whether the implementation class is reusable; if so, it creates one instance of that class and returns it for every subsequent request for that interface and name. If it is not reusable, a new instance is always created.For reasons that will become clear later, the manager actually caches a separate instance of an implementation class for each name under which it can be requested.You can ask the _PluginManager_ to forget about (decache) a plugin instance, by releasing it. See the PluginManager.releasePlugin() method. The manager will drop its reference to the plugin so the garbage collector can reclaim it. The next time that plugin/name combination is requested, it will create a new instance.h4. Getting Meta-InformationThe _PluginManager_ can list all the names of the Named Plugins which implement an interface. You may need this, for example, to implement a menu in a user interface that presents a choice among all possible plugins. See the getPluginNames() method.Note that it only returns the plugin name, so if you need a more sophisticated or meaningful "label" (i.e. a key into the I18N message catalog) then you should add a method to the plugin itself to return that.h3. ImplementationNote: The _PluginManager_ refers to interfaces and classes internally only by their names whenever possible, to avoid loading classes until absolutely necessary (i.e. to create an instance). As you'll see below, self-named classes still have to be loaded to query them for names, but for the most part it can avoid loading classes. This saves a lot of time at start-up and keeps the JVM memory footprint down, too. As the Plugin Manager gets used for more classes, this will become a greater concern.The only downside of "on-demand" loading is that errors in the configuration don't get discovered right away. The solution is to call the _checkConfiguration()_ method after making any changes to the configuration.h4. PluginManager ClassThe _PluginManager_ class is your main interface to the Plugin Manager. It behaves like a factory class that never gets instantiated, so its public methods are static.Here are the public methods, followed by explanations:* {code}static Object getSinglePlugin(Class intface)
     throws PluginConfigurationError;{code} Returns an instance of the singleton (single) plugin implementing the given interface. There must be exactly one single plugin configured for this interface, otherwise the _PluginConfigurationError_ is thrown.Note that this is the only "get plugin" method which throws an exception. It is typically used at initialization time to set up a permanent part of the system so any failure is fatal. See the _plugin.single_ configuration key for configuration details.* _static Object\[\] getPluginSequence(Class intface);_ Returns instances of all plugins that implement the interface _intface_, in an _Array_. Returns an empty array if no there are no matching plugins.The order of the plugins in the array is the same as their class names in the configuration's value field. See the _plugin.sequence_ configuration key for configuration details.* _static Object getNamedPlugin(Class intface, String name);_ Returns an instance of a plugin that implements the interface _intface_ and is bound to a name matching name. If there is no matching plugin, it returns null. The names are matched by _String.equals()_.See the _plugin.named_ and _plugin.selfnamed_ configuration keys for configuration details.* _static void releasePlugin(Object plugin);_ Tells the Plugin Manager to let go of any references to a reusable plugin, to prevent it from being given out again and to allow the object to be garbage-collected. Call this when a plugin instance must be taken out of circulation.* _static String\[\] getAllPluginNames(Class intface);_ Returns all of the names under which a named plugin implementing the interface _intface_ can be requested (with _getNamedPlugin()_). The array is empty if there are no matches. Use this to populate a menu of plugins for interactive selection, or to document what the possible choices are.The names are NOT returned in any predictable order, so you may wish to sort them first. Note: Since a plugin may be bound to more than one name, the list of names this returns does not represent the list of plugins. To get the list of unique implementation classes corresponding to the names, you might have to eliminate duplicates (i.e. create a Set of classes). * _static void checkConfiguration();_ Validates the keys in the DSpace _ConfigurationManager_ pertaining to the Plugin Manager and reports any errors by logging them. This is intended to be used interactively by a DSpace administrator, to check the configuration file after modifying it. See the section about validating configuration for details.h4. SelfNamedPlugin ClassA named plugin implementation must extend this class if it wants to supply its own Plugin Name(s). See Self-Named Plugins for why this is sometimes necessary.{code}abstract class SelfNamedPlugin
{
    // Your class must override this:
    // Return all names by which this plugin should be known.
    public static String[] getPluginNames();

    // Returns the name under which this instance was created.
    // This is implemented by SelfNamedPlugin and should NOT be
	overridden.
    public String getPluginInstanceName();
}{code}h4. Errors and Exceptions{code}public class PluginConfigurationError extends Error
{
    public PluginConfigurationError(String message);
}{code}An error of this type means the caller asked for a single plugin, but either there was no single plugin configured matching that interface, or there was more than one. Either case causes a fatal configuration error.{code}public class PluginInstantiationException extends RuntimeException
{
    public PluginInstantiationException(String msg, Throwable cause)
}{code}This exception indicates a fatal error when instantiating a plugin class. It should only be thrown when something unexpected happens in the course of instantiating a plugin, e.g. an access error, class not found, etc. Simply not finding a class in the configuration is not an exception.This is a _RuntimeException_ so it doesn't have to be declared, and can be passed all the way up to a generalized fatal exception handler.h3. Configuring PluginsAll of the Plugin Manager's configuration comes from the DSpace Configuration Manager, which is a Java Properties map. You can configure these characteristics of each plugin:# *Interface*: Classname of the Java interface which defines the plugin, including package name. e.g. _org.dspace.app.mediafilter.FormatFilter_# *Implementation Class*: Classname of the implementation class, including package. e.g. _org.dspace.app.mediafilter.PDFFilter_# *Names*: (Named plugins only) There are two ways to bind names to plugins: listing them in the value of a plugin.named.interface key, or configuring a class in _plugin.selfnamed.interface_ which extends the _SelfNamedPlugin_ class.# *Reusable option*: (Optional) This is declared in a _plugin.reusable_ configuration line. Plugins are reusable by default, so you only need to configure the non-reusable ones.h4. Configuring Singleton (Single) PluginsThis entry configures a Single Plugin for use with getSinglePlugin():_plugin.single.interface = classname_For example, this configures the class _org.dspace.checker.SimpleDispatcher_ as the plugin for interface _org.dspace.checker.BitstreamDispatcher_:_plugin.single.org.dspace.checker.BitstreamDispatcher=org.dspace.checker.SimpleDispatcher_h4. Configuring Sequence of PluginsThis kind of configuration entry defines a Sequence Plugin, which is bound to a sequence of implementation classes. The key identifies the interface, and the value is a comma-separated list of classnames:plugin.sequence.interface = classname, ...The plugins are returned by _getPluginSequence()_ in the same order as their classes are listed in the configuration value.For example, this entry configures Stackable Authentication with three implementation classes:{code}plugin.sequence.org.dspace.eperson.AuthenticationMethod = \
            org.dspace.eperson.X509Authentication, \
            org.dspace.eperson.PasswordAuthentication, \
            edu.mit.dspace.MITSpecialGroup{code}h4. Configuring Named PluginsThere are two ways of configuring named plugins:# *Plugins Named in the Configuration* A named plugin which gets its name(s) from the configuration is listed in this kind of entry:_plugin.named.interface = classname = name \[ , name.. \] \[ classname = name.. \]_The syntax of the configuration value is: classname, followed by an equal-sign and then at least one plugin name. Bind more names to the same implementation class by by adding them here, separated by commas. Names may include any character other than comma (,) and equal-sign (=). For example, this entry creates one plugin with the names GIF, JPEG, and image/png, and another with the name TeX: {code}plugin.named.org.dspace.app.mediafilter.MediaFilter = \
        org.dspace.app.mediafilter.JPEGFilter = GIF, JPEG, image/png \
        org.dspace.app.mediafilter.TeXFilter = TeX{code}This example shows a plugin name with an embedded whitespace character. Since comma (,) is the separator character between plugin names, spaces are legal (between words of a name; leading and trailing spaces are ignored). This plugin is bound to the names "Adobe PDF", "PDF", and "Portable Document Format". {code}plugin.named.org.dspace.app.mediafilter.MediaFilter = \
      org.dspace.app.mediafilter.TeXFilter = TeX \
      org.dspace.app.mediafilter.PDFFilter =  Adobe PDF, PDF, Portable Document Format{code}NOTE: Since there can only be one key with plugin.named. followed by the interface name in the configuration, all of the plugin implementations must be configured in that entry. # *Self-Named Plugins* Since a self-named plugin supplies its own names through a static method call, the configuration only has to include its interface and classname:_plugin.selfnamed.interface = classname \[ , classname.. \]_The following example first demonstrates how the plugin class, _XsltDisseminationCrosswalk_ is configured to implement its own names "MODS" and "DublinCore". These come from the keys starting with _crosswalk.dissemination.stylesheet._. The value is a stylesheet file.The class is then configured as a self-named plugin: {code}crosswalk.dissemination.stylesheet.DublinCore = xwalk/TESTDIM-2-DC_copy.xsl
crosswalk.dissemination.stylesheet.MODS = xwalk/mods.xsl

plugin.selfnamed.crosswalk.org.dspace.content.metadata.DisseminationCrosswalk = \
        org.dspace.content.metadata.MODSDisseminationCrosswalk, \
        org.dspace.content.metadata.XsltDisseminationCrosswalk
{code}NOTE: Since there can only be one key with _plugin.selfnamed._ followed by the interface name in the configuration, all of the plugin implementations must be configured in that entry. The _MODSDisseminationCrosswalk_ class is only shown to illustrate this point.h4. Configuring the Reusable Status of a PluginPlugins are assumed to be reusable by default, so you only need to configure the ones which you would prefer not to be reusable. The format is as follows:_plugin.reusable.classname = ( true | false )_For example, this marks the PDF plugin from the example above as non-reusable:_plugin.reusable.org.dspace.app.mediafilter.PDFFilter = false_h3. Validating the ConfigurationThe Plugin Manager is very sensitive to mistakes in the DSpace configuration. Subtle errors can have unexpected consequnces that are hard to detect: for example, if there are two "plugin.single" entries for the same interface, one of them will be silently ignored.To validate the Plugin Manager configuration, call the _PluginManager.checkConfiguration()_ method. It looks for the following mistakes:*  Any duplicate keys starting with "_plugin._".*  Keys starting _plugin.single_, _plugin.sequence_, _plugin.named_, and _plugin.selfnamed_ that don't include a valid interface.*  Classnames in the configuration values that don't exist, or don't implement the plugin interface in the key. *  Classes declared in plugin.selfnamed lines that don't extend the _SelfNamedPlugin_ class.*  Any name collisions among named plugins for a given interface. *  Named plugin configuration entries without any names. *  Classnames mentioned in _plugin.reusable_ keys must exist and have been configured as a plugin implementation class.The _PluginManager_ class also has a _main()_ method which simply runs _checkConfiguration()_, so you can invoke it from the command line to test the validity of plugin configuration changes.Eventually, someone should develop a general configuration-file sanity checker for DSpace, which would just call _PluginManager.checkConfiguration()._h3. Use CasesHere are some usage examples to illustrate how the Plugin Manager works.h4. Managing the MediaFilter plugins transparentlyThe existing DSpace 1.3 MediaFilterManager implementation has been largely replaced by the Plugin Manager. The MediaFilter classes become plugins named in the configuration. Refer to the configuration guide for further details.h4. A Singleton PluginThis shows how to configure and access a single anonymous plugin, such as the BitstreamDispatcher plugin:Configuration:_plugin.single.org.dspace.checker.BitstreamDispatcher=org.dspace.checker.SimpleDispatcher_The following code fragment shows how dispatcher, the service object, is initialized and used:{code}BitstreamDispatcher dispatcher =
   
	(BitstreamDispatcher)PluginManager.getSinglePlugin(BitstreamDispatcher
.class);

int id = dispatcher.next();

while (id != BitstreamDispatcher.SENTINEL)
{
     /*
        do some processing here
     */

     id = dispatcher.next();
}{code}h4. Plugin that Names ItselfThis crosswalk plugin acts like many different plugins since it is configured with different XSL translation stylesheets. Since it already gets each of its stylesheets out of the DSpace configuration, it makes sense to have the plugin give PluginManager the names to which it answers instead of forcing someone to configure those names in two places (and try to keep them synchronized).NOTE: Remember how _getPlugin()_ caches a separate instance of an implementation class for every name bound to it? This is why: the instance can look at the name under which it was invoked and configure itself specifically for that name. Since the instance for each name might be different, the Plugin Manager has to cache a separate instance for each name.Here is the configuration file listing both the plugin's own configuration and the _PluginManager_ config line:{code}crosswalk.dissemination.stylesheet.DublinCore = xwalk/TESTDIM-2-DC_copy.xsl
crosswalk.dissemination.stylesheet.MODS = xwalk/mods.xsl

plugin.selfnamed.org.dspace.content.metadata.DisseminationCrosswalk = \
  org.dspace.content.metadata.XsltDisseminationCrosswalk{code}This look into the implementation shows how it finds configuration entries to populate the array of plugin names returned by the _getPluginNames()_ method. Also note, in the _getStylesheet()_ method, how it uses the plugin name that created the current instance (returned by _getPluginInstanceName()_) to find the correct stylesheet.{code}public class XsltDisseminationCrosswalk extends SelfNamedPlugin
{
    ....
    private final String prefix =
	"crosswalk.dissemination.stylesheet.";
    ....
    public static String[] getPluginNames()
    {
        List aliasList = new ArrayList();
        Enumeration pe = ConfigurationManager.propertyNames();

        while (pe.hasMoreElements())
        {
            String key = (String)pe.nextElement();
            if (key.startsWith(prefix))
                aliasList.add(key.substring(prefix.length()));
        }
        return (String[])aliasList.toArray(new
	String[aliasList.size()]);
    }

    // get the crosswalk stylesheet for an instance of the plugin:
    private String getStylesheet()
    {
        return ConfigurationManager.getProperty(prefix +
	getPluginInstanceName());
    }
}{code}h4. Stackable AuthenticationThe Stackable Authentication mechanism needs to know all of the plugins configured for the interface, in the order of configuration, since order is significant. It gets a Sequence Plugin from the Plugin Manager. Refer to the Configuration Section on Stackable Authentication for further details.h2. Workflow SystemThe primary classes are:|_org.dspace.content.WorkspaceItem_|contains an Item before it enters a workflow ||_org.dspace.workflow.WorkflowItem_|contains an Item while in a workflow ||_org.dspace.workflow.WorkflowManager_|responds to events, manages the WorkflowItem states ||_org.dspace.content.Collection_|contains List of defined workflow steps ||_org.dspace.eperson.Group_|people who can perform workflow tasks are defined in EPerson Groups ||_org.dspace.core.Email_|used to email messages to Group members and submitters |The workflow system models the states of an Item in a state machine with 5 states (SUBMIT, STEP_1, STEP_2, STEP_3, ARCHIVE.) These are the three optional steps where the item can be viewed and corrected by different groups of people. Actually, it's more like 8 states, with STEP_1_POOL, STEP_2_POOL, and STEP_3_POOL. These pooled states are when items are waiting to enter the primary states.The WorkflowManager is invoked by events. While an Item is being submitted, it is held by a WorkspaceItem. Calling the start() method in the WorkflowManager converts a WorkspaceItem to a WorkflowItem, and begins processing the WorkflowItem's state. Since all three steps of the workflow are optional, if no steps are defined, then the Item is simply archived.Workflows are set per Collection, and steps are defined by creating corresponding entries in the List named workflowGroup. If you wish the workflow to have a step 1, use the administration tools for Collections to create a workflow Group with members who you want to be able to view and approve the Item, and the workflowGroup\[0\] becomes set with the ID of that Group.If a step is defined in a Collection's workflow, then the WorkflowItem's state is set to that step_POOL. This pooled state is the WorkflowItem waiting for an EPerson in that group to claim the step's task for that WorkflowItem. The WorkflowManager emails the members of that Group notifying them that there is a task to be performed (the text is defined in config/emails,) and when an EPerson goes to their 'My DSpace' page to claim the task, the WorkflowManager is invoked with a claim event, and the WorkflowItem's state advances from STEP_x_POOL to STEP_x (where x is the corresponding step.) The EPerson can also generate an 'unclaim' event, returning the WorkflowItem to the STEP_x_POOL.Other events the WorkflowManager handles are advance(), which advances the WorkflowItem to the next state. If there are no further states, then the WorkflowItem is removed, and the Item is then archived. An EPerson performing one of the tasks can reject the Item, which stops the workflow, rebuilds the WorkspaceItem for it and sends a rejection note to the submitter. More drastically, an abort() event is generated by the admin tools to cancel a workflow outright.h2. Administration ToolkitThe _org.dspace.administer_ package contains some classes for administering a DSpace system that are not generally needed by most applications.The _CreateAdministrator_ class is a simple command-line tool, executed via _/dspace/bin/create-administrator_, that creates an administrator e-person with information entered from standard input. This is generally used only once when a DSpace system is initially installed, to create an initial administrator who can then use the Web administration UI to further set up the system. This script does not check for authorization, since it is typically run before there are any e-people to authorize! Since it must be run as a command-line tool on the server machine, generally this shouldn't cause a problem. A possibility is to have the script only operate when there are no e-people in the system already, though in general, someone with access to command-line scripts on your server is probably in a position to do what they want anyway!The _DCType_ class is similar to the _org.dspace.content.BitstreamFormat_ class. It represents an entry in the Dublin Core type registry, that is, a particular element and qualifier, or unqualified element. It is in the _administer_ package because it is only generally required when manipulating the registry itself. Elements and qualifiers are specified as literals in _org.dspace.content.Item_ methods and the _org.dspace.content.DCValue_ class. Only administrators may modify the Dublin Core type registry.The _org.dspace.administer.RegistryLoader_ class contains methods for initialising the Dublin Core type registry and bitstream format registry with entries in an XML file. Typically this is executed via the command line during the build process (see _build.xml_ in the source.) To see examples of the XML formats, see the files in _config/registries_ in the source directory. There is no XML schema, they aren't validated strictly when loaded in.h2. E-person/Group ManagerDSpace keeps track of registered users with the _org.dspace.eperson.EPerson_ class. The class has methods to create and manipulate an _EPerson_ such as get and set methods for first and last names, email, and password. (Actually, there is no _getPassword()_ method--an MD5 hash of the password is stored, and can only be verified with the _checkPassword()_ method.) There are find methods to find an EPerson by email (which is assumed to be unique,) or to find all EPeople in the system.The _EPerson_ object should probably be reworked to allow for easy expansion; the current EPerson object tracks pretty much only what MIT was interested in tracking - first and last names, email, phone. The access methods are hardcoded and should probably be replaced with methods to access arbitrary name/value pairs for institutions that wish to customize what EPerson information is stored.Groups are simply lists of _EPerson_ objects. Other than membership, _Group_ objects have only one other attribute: a name. Group names must be unique, so we have adopted naming conventions where the role of the group is its name, such as _COLLECTION_100_ADD_. Groups add and remove EPerson objects with _addMember()_ and _removeMember()_ methods. One important thing to know about groups is that they store their membership in memory until the _update()_ method is called - so when modifying a group's membership don't forget to invoke _update()_ or your changes will be lost! Since group membership is used heavily by the authorization system a fast _isMember()_ method is also provided.Another kind of Group is also implemented in DSpace--special Groups. The _Context_ object for each session carries around a List of Group IDs that the user is also a member of--currently the MITUser Group ID is added to the list of a user's special groups if certain IP address or certificate criteria are met.h2. AuthorizationThe primary classes are:|_org.dspace.authorize.AuthorizeManager_|does all authorization, checking policies against Groups ||_org.dspace.authorize.ResourcePolicy_|defines all allowable actions for an object ||_org.dspace.eperson.Group_|all policies are defined in terms of EPerson Groups |The authorization system is based on the classic 'police state' model of security; no action is allowed unless it is expressed in a policy. The policies are attached to resources (hence the name _ResourcePolicy_,) and detail who can perform that action. The resource can be any of the DSpace object types, listed in _org.dspace.core.Constants_ (_BITSTREAM_, _ITEM_, _COLLECTION_, etc.) The 'who' is made up of EPerson groups. The actions are also in _Constants.java_ (_READ_, _WRITE_, _ADD_, etc.) The only non-obvious actions are _ADD_ and _REMOVE_, which are authorizations for container objects. To be able to create an Item, you must have _ADD_ permission in a Collection, which contains Items. (Communities, Collections, Items, and Bundles are all container objects.)Currently most of the read policy checking is done with items--communities and collections are assumed to be openly readable, but items and their bitstreams are checked. Separate policy checks for items and their bitstreams enables policies that allow publicly readable items, but parts of their content may be restricted to certain groups.The _AuthorizeManager_ class'
      _authorizeAction(Context, object, action)_ is the primary source of all authorization in the system. It gets a list of all of the ResourcePolicies in the system that match the object and action. It then iterates through the policies, extracting the EPerson Group from each policy, and checks to see if the EPersonID from the Context is a member of any of those groups. If all of the policies are queried and no permission is found, then an _AuthorizeException_ is thrown. An _authorizeAction()_ method is also supplied that returns a boolean for applications that require higher performance.ResourcePolicies are very simple, and there are quite a lot of them. Each can only list a single group, a single action, and a single object. So each object will likely have several policies, and if multiple groups share permissions for actions on an object, each group will get its own policy. (It's a good thing they're small.)h3. Special GroupsAll users are assumed to be part of the public group (ID=0.) DSpace admins (ID=1) are automatically part of all groups, much like super-users in the Unix OS. The Context object also carries around a List of special groups, which are also first checked for membership. These special groups are used at MIT to indicate membership in the MIT community, something that is very difficult to enumerate in the database! When a user logs in with an MIT certificate or with an MIT IP address, the login code adds this MIT user group to the user's Context.h3. Miscellaneous Authorization NotesWhere do items get their read policies? From the their collection's read policy. There once was a separate item read default policy in each collection, and perhaps there will be again since it appears that administrators are notoriously bad at defining collection's read policies. There is also code in place to enable policies that are timed--have a start and end date. However, the admin tools to enable these sorts of policies have not been written.h2. Handle Manager/Handle PluginThe _org.dspace.handle_ package contains two classes; _HandleManager_ is used to create and look up Handles, and _HandlePlugin_ is used to expose and resolve DSpace Handles for the outside world via the CNRI Handle Server code.Handles are stored internally in the _handle_ database table in the form:_1721.123/4567_Typically when they are used outside of the system they are displayed in either URI or "URL proxy" forms:{code}hdl:1721.123/4567
http://hdl.handle.net/1721.123/4567{code}It is the responsibility of the caller to extract the basic form from whichever displayed form is used.The _handle_ table maps these Handles to resource type/resource ID pairs, where resource type is a value from _org.dspace.core.Constants_ and resource ID is the internal identifier (database primary key) of the object. This allows Handles to be assigned to any type of object in the system, though as explained in the functional overview, only communities, collections and items are presently assigned Handles._HandleManager_ contains static methods for:*  Creating a Handle *  Finding the Handle for a _DSpaceObject_, though this is usually only invoked by the object itself, since _DSpaceObject_ has a _getHandle_ method*  Retrieving the _DSpaceObject_ identified by a particular Handle*  Obtaining displayable forms of the Handle (URI or "proxy URL"). _HandlePlugin_ is a simple implementation of the Handle Server's _net.handle.hdllib.HandleStorage_ interface. It only implements the basic Handle retrieval methods, which get information from the _handle_ database table. The CNRI Handle Server is configured to use this plug-in via its _config.dct_ file.Note that since the Handle server runs as a separate JVM to the DSpace Web applications, it uses a separate 'Log4J' configuration, since Log4J does not support multiple JVMs using the same daily rolling logs. This alternative configuration is held as a template in _/dspace/config/templates/log4j-handle-plugin.properties_, written to _/dspace/config/log4j-handle-plugin.properties_ by the _install-configs_ script. The _/dspace/bin/start-handle-server_ script passes in the appropriate command line parameters so that the Handle server uses this configuration.h2. SearchDSpace's search code is a simple API which currently wraps the Lucene search engine. The first half of the search task is indexing, and _org.dspace.search.DSIndexer_ is the indexing class, which contains _indexContent()_ which if passed an _Item_, _Community_, or _Collection_, will add that content's fields to the index. The methods _unIndexContent()_ and _reIndexContent()_ remove and update content's index information. The _DSIndexer_ class also has a _main()_ method which will rebuild the index completely. This can be invoked by the _dspace/bin/index-init_ (complete rebuild) or _dspace/bin/index-update_ (update) script. The intent was for the _main()_ method to be invoked on a regular basis to avoid index corruption, but we have had no problem with that so far.Which fields are indexed by _DSIndexer_? These fields are defined in dspace.cfg in the section "Fields to index for search" as name-value-pairs. The name must be unique in the form search.index.i (i is an arbitrary positive number). The value on the right side has a unique value again, which can be referenced in search-form (e.g. title, author). Then comes the metadata element which is indexed. '*' is a wildcard which includes all subelements. For example:_search.index.4 = keyword:dc.subject.*_tells the indexer to create a keyword index containing all dc.subject element values. Since the wildcard ('*') character was used in place of a qualifier, all subject metadata fields will be indexed (e.g. dc.subject.other, dc.subject.lcsh, etc)By default, the fields shown in the _Indexed Fields_ section below are indexed. These are hardcoded in the DSIndexer class. If any search.index.i items are specified in _dspace.cfg_ these are used rather than these hardcoded fields.The query class _DSQuery_ contains the three flavors of _doQuery()_ methods--one searches the DSpace site, and the other two restrict searches to Collections and Communities. The results from a query are returned as three lists of handles; each list represents a type of result. One list is a list of Items with matches, and the other two are Collections and Communities that match. This separation allows the UI to handle the types of results gracefully without resolving all of the handles first to see what kind of content the handle points to. The _DSQuery_ class also has a _main()_ method for debugging via command-line searches.h3. Current Lucene ImplementationCurrently we have our own Analyzer and Tokenizer classes (_DSAnalyzer_ and _DSTokenizer_) to customize our indexing. They invoke the stemming and stop word features within Lucene. We create an _IndexReader_ for each query, which we now realize isn't the most efficient use of resources - we seem to run out of filehandles on really heavy loads. (A wildcard query can open many filehandles!) Since Lucene is thread-safe, a better future implementation would be to have a single Lucene IndexReader shared by all queries, and then is invalidated and re-opened when the index changes. Future API growth could include relevance scores (Lucene generates them, but we ignore them,) and abstractions for more advanced search concepts such as booleans.h3. Indexed FieldsThe _DSIndexer_ class shipped with DSpace indexes the Dublin Core metadata in the following way:|*Search Field*|*Taken from Dublin Core Fields*||Authors |_contributor.*__creator.*__description.statementofresponsibility_||Titles |_title.*_||Keywords |_subject.*_||Abstracts |_description.abstract__description.tableofcontents_||Series |_relation.ispartofseries_||MIME types |_format.mimetype_||Sponsors |_description.sponsorship_||Identifiers |_identifier.*_|h3. Harvesting APIThe _org.dspace.search_ package also provides a 'harvesting' API. This allows callers to extract information about items modified within a particular timeframe, and within a particular scope (all of DSpace, or a community or collection.) Currently this is used by the Open Archives Initiative metadata harvesting protocol application, and the e-mail subscription code.The _Harvest.harvest_ is invoked with the required scope and start and end dates. Either date can be omitted. The dates should be in the ISO8601, UTC time zone format used elsewhere in the DSpace system._HarvestedItemInfo_ objects are returned. These objects are simple containers with basic information about the items falling within the given scope and date range. Depending on parameters passed to the _harvest_ method, the _containers_ and _item_ fields may have been filled out with the IDs of communities and collections containing an item, and the corresponding _Item_ object respectively. Electing not to have these fields filled out means the harvest operation executes considerable faster.In case it is required, _Harvest_ also offers a method for creating a single _HarvestedItemInfo_ object, which might make things easier for the caller.h2. Browse APIThe browse API maintains indices of dates, authors, titles and subjects, and allows callers to extract parts of these:* **Title**:  Values of the Dublin Core element *title* (unqualified) are indexed. These are sorted in a case-insensitive fashion, with any leading article removed. For example:_The DSpace System_Appears under 'D' rather than 'T'. * **Author**:  Values of the *contributor* (any qualifier or unqualified) element are indexed. Since _contributor_ values typically are in the form 'last name, first name', a simple case-insensitive alphanumeric sort is used which orders authors in last name order.Note that this is an index of _authors_, and not _items by author_. If four items have the same author, that author will appear in the index only once. Hence, the index of authors may be greater or smaller than the index of titles; items often have more than one author, though the same author may have authored several items.The author indexing in the browse API does have limitations: **  Ideally, a name that appears as an author for more than one item would appear in the author index only once. For example, 'Doe, John' may be the author of tens of items. However, in practice, author's names often appear in slightly differently forms, for example: {code}Doe, John
Doe, John Stewart
Doe, John S.{code}Currently, the above three names would all appear as separate entries in the author index even though they may refer to the same author. In order for an author of several papers to be correctly appear once in the index, each item must specify _exactly_ the same form of their name, which doesn't always happen in practice.**  Another issue is that two authors may have the same name, even within a single institution. If this is the case they may appear as one author in the index. These issues are typically resolved in libraries with _authority control records_, in which are kept a 'preferred' form of the author's name, with extra information (such as date of birth/death) in order to distinguish between authors of the same name. Maintaining such records is a huge task with many issues, particularly when metadata is received from faculty directly rather than trained library cataloguers. For these reasons, DSpace does not yet feature 'authority control' functionality.* **Date of Issue**:  Items are indexed by date of issue. This may be different from the date that an item appeared in DSpace; many items may have been originally published elsewhere beforehand. The Dublin Core field used is *date.issued*. The ordering of this index may be reversed so 'earliest first' and 'most recent first' orderings are possible.Note that the index is of _items by date_, as opposed to an index of _dates_. If 30 items have the same issue date (say 2002), then those 30 items all appear in the index adjacent to each other, as opposed to a single 2002 entry.Since dates in DSpace Dublin Core are in ISO8601, all in the UTC time zone, a simple alphanumeric sort is sufficient to sort by date, including dealing with varying granularities of date reasonably. For example: {code}2001-12-10
2002
2002-04
2002-04-05
2002-04-09T15:34:12Z
2002-04-09T19:21:12Z
2002-04-10{code}* **Date Accessioned**:  In order to determine which items most recently appeared, rather than using the date of issue, an item's accession date is used. This is the Dublin Core field *date.accessioned*. In other aspects this index is identical to the date of issue index.* **Items by a Particular Author**:  The browse API can perform is to extract items by a particular author. They do not have to be primary author of an item for that item to be extracted. You can specify a scope, too; that is, you can ask for items by author X in collection Y, for example. This particular flavour of browse is slightly simpler than the others. You cannot presently specify a particular subset of results to be returned. The API call will simply return all of the items by a particular author within a certain scope. Note that the author of the item must _exactly_ match the author passed in to the API; see the explanation about the caveats of the author index browsing to see why this is the case.* **Subject**:  Values of the Dublin Core element *subject* (both unqualified and with any qualifier) are indexed. These are sorted in a case-insensitive fashion.h3. Using the APIThe API is generally invoked by creating a _BrowseScope_ object, and setting the parameters for which particular part of an index you want to extract. This is then passed to the relevent _Browse_ method call, which returns a _BrowseInfo_ object which contains the results of the operation. The parameters set in the _BrowseScope_ object are:* How many entries from the index you want * Whether you only want entries from a particular community or collection, or from the whole of DSpace * Which part of the index to start from (called the _focus_ of the browse). If you don't specify this, the start of the index is used* How many entries to include before the _focus_ entryTo illustrate, here is an example:* We want *7* entries in total* We want entries from collection _x_* We want the focus to be 'Really' * We want *2* entries included before the focus.The results of invoking _Browse.getItemsByTitle_ with the above parameters might look like this:{code}        Rabble-Rousing Rabbis From Sardinia
        Reality TV: Love It or Hate It?
FOCUS>  The Really Exciting Research Video
        Recreational Housework Addicts: Please Visit My House
        Regional Television Variation Studies
        Revenue Streams
        Ridiculous Example Titles:  I'm Out of Ideas{code}Note that in the case of title and date browses, _Item_ objects are returned as opposed to actual titles. In these cases, you can specify the 'focus' to be a specific item, or a partial or full literal value. In the case of a literal value, if no entry in the index matches exactly, the closest match is used as the focus. It's quite reasonable to specify a focus of a single letter, for example.Being able to specify a specific item to start at is particularly important with dates, since many items may have the save issue date. Say 30 items in a collection have the issue date 2002. To be able to page through the index 20 items at a time, you need to be able to specify exactly which item's 2002 is the focus of the browse, otherwise each time you invoked the browse code, the results would start at the first item with the issue date 2002.Author browses return _String_ objects with the actual author names. You can only specify the focus as a full or partial literal _String_.Another important point to note is that presently, the browse indices contain metadata for all items in the main archive, regardless of authorization policies. This means that all items in the archive will appear to all users when browsing. Of course, should the user attempt to access a non-public item, the usual authorization mechanism will apply. Whether this approach is ideal is under review; implementing the browse API such that the results retrieved reflect a user's level of authorization may be possible, but rather tricky.h3. Index MaintenanceThe browse API contains calls to add and remove items from the index, and to regenerate the indices from scratch. In general the content management API invokes the necessary browse API calls to keep the browse indices in sync with what is in the archive, so most applications will not need to invoke those methods.If the browse index becomes inconsistent for some reason, the _InitializeBrowse_ class is a command line tool (generally invoked using the _/dspace/bin/dspace index-init_ command) that causes the indexes to be regenerated from scratch.h3. CaveatsPresently, the browse API is not tremendously efficient. 'Indexing' takes the form of simply extracting the relevant Dublin Core value, normalising it (lower-casing and removing any leading article in the case of titles), and inserting that normalized value with the corresponding item ID in the appropriate browse database table. Database views of this table include collection and community IDs for browse operations with a limited scope. When a browse operation is performed, a simple _SELECT_ query is performed, along the lines of:{code}SELECT item_id FROM ItemsByTitle ORDER BY sort_title OFFSET 40 LIMIT 20{code}There are two main drawbacks to this: Firstly, _LIMIT_ and _OFFSET_ are PostgreSQL-specific keywords. Secondly, the database is still actually performing dynamic sorting of the titles, so the browse code as it stands will not scale particularly well. The code does cache _BrowseInfo_ objects, so that common browse operations are performed quickly, but this is not an ideal solution.h2. Checksum checkerChecksum checker is used to verify every item within DSpace.  While DSpace calculates and records the checksum of every file submitted to it, the checker  can determine whterh the file has been changed.  The idea being that the earlier you can identify a file has changed, the more likely you would be able to record it (assuming it was not a wanted change)._org.dspace.checker.CheckerCommand_ class, is the class for the checksum checker tool, which calculates checksums for each bitstream whose ID is in the _most_recent_checksum_ table, and compares it against the last calculated checksum for that bitstream.h2. OpenSearch SupportDSpace is able to support OpenSearch. For those not aquainted with the standard, a very brief introduction, with emphasis on what possibilities it holds for current use and future development.OpenSearch is a small set of conventions and documents for describing and using 'search engines', meaning any service that returns a set of results for a query. It is nearly ubiquitous—but also nearly invisible—in modern web sites with search capability. If you look at the page source of Wikipedia, Facebook, CNN, etc you will find buried a link element declaring OpenSearch support. It is very much a lowest-common-denominator abstraction (think Google box), but does provide a means to extend its expressive power. This first implementation for DSpace supports _none_ of these extensions—many of which are of potential value—so it should be regarded as a foundation, not a finished solution. So the short answer is that DSpace appears as a 'search-engine' to OpenSearch-aware software.Another way to look at OpenSearch is as a RESTful web service for search, very much like SRW/U, but considerably simpler. This comparative loss of power is offset by the fact that it is widely supported by web tools and players: browsers understand it, as do large metasearch tools. *How Can It Be Used** Browser Integration Many recent browsers (IE7+, FF2+) can detect, or 'autodiscover', links to the document describing the search engine. Thus you can easily add your or other DSpace instances to the drop-down list of search engines in your browser. This list typically appears in the upper right corner of the browser, with a search box. In Firefox, for example, when you visit a site supporting OpenSearch, the color of the drop-down list widget changes color, and if you open it to show the list of search engines, you are offered an opportunity to add the site to the list. IE works nearly the same way but instead labels the web sites 'search providers'. When you select a DSpace instance as the search engine and enter a search, you are simply sent to the regular search results page of the instance. * Flexible, interesting RSS Feeds Because one of the formats that OpenSearch specifies for its results is RSS (or Atom), you can turn any search query into an RSS feed. So if there are keywords highly discriminative of content in a collection or repository, these can be turned into a URL that a feed reader can subscribe to. Taken to the extreme, one could take any search a user makes, and dynamically compose an RSS feed URL for it in the page of returned results. To see an example, if you have a DSpace with OpenSearch enabled, try: http://dspace.mysite.edu/open-search/?query-<your query> The default format returned is Atom 1.0, so you should see an Atom document containing your search results. * You can extend the syntax witha few other parameters, as follows: |Parameter |Values ||format |atom, rss, html ||scope |<handle>—search is restricted to a collection or communith with the indicated handle. ||rpp |number indicating the number of results per page (i.e. per request) ||start |number of page to start with (if paginating results) ||sort_by |number indicating sorting criteria (same as DSpace advanced search values |* Cheap metasearch Search aggregators like A9 (Amazon) recognize OpenSearch-compliant providers, and so can be added to metasearch sets using their UIs. Then you site can be used to aggregate search results with others. Configuration is throught the _dspace.cfg file._See OpenSearch Supporth2. EmbargoThe architecture of Embarge is documentated in the package javadocs.  Run _cd /\[dspace-source\]/dspace;mvn javadoc:javadoc_ and look in _\[dspace-source\]/dspace-api/target/site/apidocs/index.html_.