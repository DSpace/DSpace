<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"
    default-lazy-init="true">


    <!-- ******************** -->
    <!-- Service declarations -->
    <!-- ******************** -->
    <bean class="org.dspace.app.requestitem.RequestItemServiceImpl"/>

    <bean class="org.dspace.app.itemexport.ItemExportServiceImpl"/>

    <!--Ensure that bean remains prototype ! Uses setters to set certain properties such as should is pass through workflow-->
    <bean class="org.dspace.app.itemimport.ItemImportServiceImpl" scope="prototype"/>

    <!--Ensure that bean remains prototype ! -->
    <bean class="org.dspace.app.mediafilter.MediaFilterServiceImpl" scope="prototype"/>

    <bean class="org.dspace.app.sfx.SFXFileReaderServiceImpl" scope="prototype"/>

    <bean class="org.dspace.app.util.MetadataExposureServiceImpl"/>
    <bean class="org.dspace.app.util.OpenSearchServiceImpl"/>
    <bean class="org.dspace.app.util.WebAppServiceImpl"/>

    <bean class="org.dspace.authenticate.AuthenticationServiceImpl"/>

    <bean class="org.dspace.authorize.AuthorizeServiceImpl"/>
    <bean class="org.dspace.authorize.ResourcePolicyServiceImpl"/>

    <bean class="org.dspace.authority.AuthorityValueServiceImpl"/>
    <bean class="org.dspace.authority.AuthorityServiceImpl"/>

    <bean class="org.dspace.checker.ChecksumHistoryServiceImpl"/>
    <bean class="org.dspace.checker.ChecksumResultServiceImpl"/>
    <bean class="org.dspace.checker.MostRecentChecksumServiceImpl"/>
    <bean class="org.dspace.checker.SimpleReporterServiceImpl"/>

    <bean class="org.dspace.content.CollectionServiceImpl"/>
    <bean class="org.dspace.content.BitstreamFormatServiceImpl"/>
    <bean class="org.dspace.content.BitstreamServiceImpl"/>
    <bean class="org.dspace.content.BundleServiceImpl"/>
    <bean class="org.dspace.content.CommunityServiceImpl"/>
    <bean class="org.dspace.content.InstallItemServiceImpl"/>
    <bean class="org.dspace.content.ItemServiceImpl"/>
    <bean class="org.dspace.content.MetadataFieldServiceImpl"/>
    <bean class="org.dspace.content.MetadataSchemaServiceImpl"/>
    <bean class="org.dspace.content.MetadataValueServiceImpl"/>
    <bean class="org.dspace.content.SiteServiceImpl"/>
    <bean class="org.dspace.content.SupervisedItemServiceImpl"/>
    <bean class="org.dspace.content.WorkspaceItemServiceImpl"/>
    <bean class="org.dspace.content.RelationshipServiceImpl"/>
    <bean class="org.dspace.content.EntityTypeServiceImpl"/>
    <bean class="org.dspace.content.EntityServiceImpl"/>
    <bean class="org.dspace.content.RelationshipTypeServiceImpl"/>

    <bean class="org.dspace.content.authority.ChoiceAuthorityServiceImpl"/>
    <bean class="org.dspace.content.authority.MetadataAuthorityServiceImpl" lazy-init="true"/>

    <!-- Ensure PluginService is initialized properly via init() method -->
    <bean class="org.dspace.core.LegacyPluginServiceImpl" init-method="init"/>
    <bean class="org.dspace.core.LicenseServiceImpl"/>
    <bean class="org.dspace.core.NewsServiceImpl">
   		<property name="acceptableFilenames">
			<list>
				<value>news-top.html</value>
				<value>news-side.html</value>
			</list>
		</property>
	</bean>

    <!-- Ensure WorkflowCuratorService is initialized properly via init() method -->
    <bean class="org.dspace.curate.WorkflowCuratorServiceImpl" init-method="init"/>

    <bean class="org.dspace.disseminate.CitationDocumentServiceImpl"/>

    <!-- Ensure EmbargoService is initialized properly via init() method -->
    <bean class="org.dspace.embargo.EmbargoServiceImpl" init-method="init"/>

    <bean class="org.dspace.eperson.AccountServiceImpl"/>
    <bean class="org.dspace.eperson.EPersonServiceImpl"/>
    <bean class="org.dspace.eperson.GroupServiceImpl"/>
    <bean class="org.dspace.eperson.RegistrationDataServiceImpl"/>
    <bean class="org.dspace.eperson.SubscribeServiceImpl"/>
    <bean class="org.dspace.eperson.SupervisorServiceImpl"/>

    <bean class="org.dspace.event.EventServiceImpl"/>

    <bean class="org.dspace.handle.HandleServiceImpl"/>

    <bean class="org.dspace.harvest.HarvestedCollectionServiceImpl"/>
    <bean class="org.dspace.harvest.HarvestedItemServiceImpl"/>
    <bean class="org.dspace.harvest.HarvestSchedulingServiceImpl"/>

    <bean class="org.dspace.identifier.DOIServiceImpl"/>

    <bean class="org.dspace.license.CreativeCommonsServiceImpl"/>

    <bean id="spiderDetectorService" class="org.dspace.statistics.util.SpiderDetectorServiceImpl"/>
    <bean id="clientInfoService" class="org.dspace.service.impl.ClientInfoServiceImpl"/>

    <bean class="org.dspace.versioning.VersionHistoryServiceImpl"/>

    <!--Basic workflow services, comment or remove when switching to the configurable workflow -->
    <bean class="org.dspace.workflowbasic.TaskListItemServiceImpl"/>
    <bean class="org.dspace.workflowbasic.BasicWorkflowItemServiceImpl"/>
    <bean class="org.dspace.workflowbasic.BasicWorkflowServiceImpl"/>

    <!--Configurable workflow services, uncomment the xml workflow beans below to enable the configurable workflow-->
    <!--<bean class="org.dspace.xmlworkflow.storedcomponents.ClaimedTaskServiceImpl"/>
    <bean class="org.dspace.xmlworkflow.storedcomponents.CollectionRoleServiceImpl"/>
    <bean class="org.dspace.xmlworkflow.storedcomponents.InProgressUserServiceImpl"/>
    <bean class="org.dspace.xmlworkflow.storedcomponents.PoolTaskServiceImpl"/>
    <bean class="org.dspace.xmlworkflow.storedcomponents.WorkflowItemRoleServiceImpl"/>
    <bean class="org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItemServiceImpl"/>
    <bean class="org.dspace.xmlworkflow.XmlWorkflowServiceImpl"/>
    <bean class="org.dspace.xmlworkflow.WorkflowRequirementsServiceImpl"/>
    <bean class="org.dspace.xmlworkflow.XmlWorkflowFactoryImpl"/>-->
    <bean class="org.dspace.content.virtual.VirtualMetadataPopulator">
        <property name="map">
            <!-- This map contains keys and value-refs to Map objects
                 The keys will define which relationship type will add virtual metadata
                 to its relationship's item and the map will define which virtual metadata fields
                 are to be added to the item that has a relationship with this relationship type-->
            <map>
                <entry key="isAuthorOfPublication" value-ref="isAuthorOfPublicationMap"/>
                <entry key="isOrgUnitOfPublication" value-ref="isOrgUnitOfPublicationMap"/>
                <entry key="isPersonOfProject" value-ref="isPersonOfProjectMap"/>
                <entry key="isOrgUnitOfProject" value-ref="isOrgUnitOfProjectMap"/>
                <entry key="isOrgUnitOfPerson" value-ref="isOrgUnitOfPersonMap"/>
                <entry key="isJournalVolumeOfIssue" value-ref="isJournalVolumeOfIssueMap"/>
                <entry key="isJournalOfVolume" value-ref="isJournalOfVolumeMap"/>
		        <entry key="isVolumeOfJournal" value-ref="isVolumeOfJournalMap"/>
                <entry key="isIssueOfJournalVolume" value-ref="isIssueOfJournalVolumeMap"/>
                <entry key="isJournalIssueOfPublication" value-ref="isJournalIssueOfPublicationMap"/>
            </map>
        </property>
    </bean>

    <bean class="org.dspace.content.virtual.EntityTypeToFilterQueryService">
        <property name="map">
            <map>
                <entry key="Publication" value="f.entityType=Publication,equals"/>
                <entry key="Person" value="f.entityType=Person,equals"/>
                <entry key="Journal" value="f.entityType=Journal,equals"/>
            </map>
        </property>
    </bean>

    <!-- Config like this will tell our VirtualMetadataPopulator to include the virtual metadata field
         'dc.contributor.author' on the appropriate item with the values defined in the value-ref.
          This value-ref should be a bean of type VirtualBean -->
    <util:map id="isAuthorOfPublicationMap">
        <entry key="dc.contributor.author" value-ref="publicationAuthor_author"/>
    </util:map>
    <!-- This Concatenate bean will take all the values of each metadata field configured in the list
         and it will join all of these together with the separator defined in this bean. This means that whichever
         entry this bean belongs to, that metadata field will have the value of the related item's metadata values
         joined together with this separator.
         If the related item has:
            person.identifier.lastname = Smith
            person.identifier.firstname = John
         Then the original item will have, in this case:
            dc.contributor.author = Smith, John -->
    <bean class="org.dspace.content.virtual.Concatenate" id="publicationAuthor_author">
        <property name="fields">
            <util:list>
                <value>person.identifier.lastname</value>
                <value>person.identifier.firstname</value>
            </util:list>
        </property>
        <property name="separator">
            <value>, </value>
        </property>
    </bean>

    <!-- Config like this will tell our VirtualMetadataPopulator to include the virtual metadata field
     'dc.contributor.other' on the appropriate item with the values defined in the value-ref.
      This value-ref should be a bean of type VirtualBean -->
    <util:map id="isOrgUnitOfPublicationMap">
        <entry key="dc_contributor_other" value-ref="publicationOrgUnit_name"/>
    </util:map>
    <bean class="org.dspace.content.virtual.Collected" id="publicationOrgUnit_name">
        <property name="fields">
            <util:list>
                <value>orgunit.identifier.name</value>
            </util:list>
        </property>
    </bean>

    <util:map id="isPersonOfProjectMap">
        <entry key="project_contributor_author" value-ref="projectPerson_author"/>
    </util:map>
    <!-- This Concatenate bean will take all the values of each metadata field configured in the list
     and it will join all of these together with the separator defined in this bean. This means that whichever
     entry this bean belongs to, that metadata field will have the value of the related item's metadata values
     joined together with this separator.
     If the related item has:
        person.identifier.lastname = Smith
        person.identifier.firstname = John
     Then the original item will have, in this case:
        dc.contributor.author = Smith, John -->
    <bean class="org.dspace.content.virtual.Concatenate" id="projectPerson_author">
        <property name="fields">
            <util:list>
                <value>person.identifier.lastname</value>
                <value>person.identifier.firstname</value>
            </util:list>
        </property>
        <property name="separator">
            <value>, </value>
        </property>
    </bean>

    <util:map id="isOrgUnitOfProjectMap">
        <entry key="project_contributor_other" value-ref="projectOrgUnit_other"/>
    </util:map>
    <!-- This Collected bean will take all the values of each metadata field defined in the list and it'll
         create a list of virtual metadata fields defined by the map in which it's defined.
         In this case it'll create a list of project.contributor.other virtual metadata fields that hold
         the value of orgunit.identifier.name, each of them in a separate metadatavalue
         If the related item has:
            orgunit.identifier.name = Generic name
            orgunit.identifier.name = Even more generic name
         Then the original item will have, in this case:
            project.contributor.other = Generic name
            project.contributor.other = Even more generic name -->
    <bean class="org.dspace.content.virtual.Collected" id="projectOrgUnit_other">
        <property name="fields">
            <util:list>
                <value>orgunit.identifier.name</value>
            </util:list>
        </property>
    </bean>

    <util:map id="isOrgUnitOfPersonMap">
        <entry key="person_contributor_other" value-ref="personProject_other"/>
    </util:map>
    <bean class="org.dspace.content.virtual.Collected" id="personProject_other">
        <property name="fields">
            <util:list>
                <value>orgunit.identifier.name</value>
            </util:list>
        </property>
    </bean>

    <util:map id="isJournalVolumeOfIssueMap">
        <entry key="journalvolume.identifier.volume" value-ref="issueVolume_volume"/>
        <entry key="journal.identifier.issn" value-ref="volumeJournal_issn_related"/>
    </util:map>
    <!-- This Collected bean will take all the values of each metadata field defined in the list and it'll
     create a list of virtual metadata fields defined by the map in which it's defined.
     In this case it'll create a list of journalvolume.identifier.volume virtual metadata fields that hold
     the value of journalvolume.identifier.volume, each of them in a separate metadatavalue
     If the related item has:
        journalvolume.identifier.volume = Generic volume
        journalvolume.identifier.volume = Even more generic volume
     Then the original item will have, in this case:
        journalvolume.identifier.volume = Generic volume
        journalvolume.identifier.volume = Even more generic volume
     Note that these metadata fields have the same signature of schema, element and qualifier, but that poses no problem
     -->
    <bean class="org.dspace.content.virtual.Collected" id="issueVolume_volume">
        <property name="fields">
            <util:list>
                <value>journalvolume.identifier.volume</value>
            </util:list>
        </property>
    </bean>
    <!-- This is a Related bean, which will find the relationshiptype defined in the relationshipTypeString property on
         the current item and it'll use the related item from that relationship to pass it along to the virtualBean
         property which in turn refers to another VirtualBean instance and it continues the chain until it reaches
         either a Concatenate or Collected bean to retrieve the values. It will then return that value through the chain
         again and it'll fill the values into the virtual metadata fields that are defined in the map for the first
         Related bean.
         Lets look at this example: we've defined a Related bean for a relationship type that will be used on a
         journal issue.
            The journal issue will receive 2 metadata fields if we look at the map 'isJournalVolumeOfIssueMap' it'll
            receive the journalvolume.identifier.volume metadata field and the journal.identifier.issn metadata field.
         Since the journal.identifier.issn metadata field can't be filled in through the metadata of the journalvolume
         alone, we need to pass this call higher up the chain to the journalvolume's relationships to find the journal.
         Therefore we've created this Related bean which will look at the journalvolume's relationships with type
         'isJournalOfVolume' to find the journal that this journalvolume is related to and it'll then call the next
         VirtualBean with that journal to retrieve the value. This will leave the retrieving of the values to the
         next bean in the chain -->
    <bean class="org.dspace.content.virtual.Related" id="volumeJournal_issn_related">
        <property name="relationshipTypeString" value="isJournalOfVolume"/>
        <property name="place" value="1"/>
        <property name="virtualBean" ref="volumeJournal_issn"/>
    </bean>

    <util:map id="isJournalOfVolumeMap">
        <entry key="journal.identifier.issn" value-ref="volumeJournal_issn"/>
        <entry key="journal.title" value-ref="volumeJournal_title"/>
    </util:map>
    <bean class="org.dspace.content.virtual.Collected" id="volumeJournal_issn">
        <property name="fields">
            <util:list>
                <value>journal.identifier.issn</value>
            </util:list>
        </property>
    </bean>
    <bean class="org.dspace.content.virtual.Collected" id="volumeJournal_title">
        <property name="fields">
            <util:list>
                <value>journal.identifier.name</value>
            </util:list>
        </property>
    </bean>

    <util:map id="isVolumeOfJournalMap">
    </util:map>
	
    <util:map id="isIssueOfJournalVolumeMap">
        <entry key="journalissue_identifier_number" value-ref="journalIssue_number"/>
    </util:map>
    <bean class="org.dspace.content.virtual.Collected" id="journalIssue_number">
        <property name="fields">
            <util:list>
                <value>journalissue.identifier.number</value>
            </util:list>
        </property>
    </bean>

    <util:map id="isJournalIssueOfPublicationMap">
        <entry key="journal.identifier.issn"  value-ref="issueVolumeJournal_issn_related"/>
    </util:map>

    <!-- This is a Related bean, which will find the relationshiptype defined in the relationshipTypeString property on
     the current item and it'll use the related item from that relationship to pass it along to the virtualBean
     property which in turn refers to another VirtualBean instance and it continues the chain until it reaches
     either a Concatenate or Collected bean to retrieve the values. It will then return that value through the chain
     again and it'll fill the values into the virtual metadata fields that are defined in the map for the first
     Related bean.
     Lets look at this example: we've defined a Related bean for a relationship type that will be used on a publication.
        The publication will receive 1 virtual metadata value namely the journal.identifier.issn to which it belongs
     Since the journal.identifier.issn metadata field can't be filled in through the metadata of the journalIssue
     alone, we need to pass this call higher up the chain to the journalissue's relationships to find the journal.
     Therefore we've created this Related bean which will look at the journalissue's relationships with type
     'isJournalVolumeOfIssue' to find the journalvolume that this journalissue is related to and it'll then call the next
     VirtualBean with that journalvolume to retrieve the value. This will leave the retrieving of the values to the
     next bean in the chain.
     In this specific case, it'll call another Related bean to retrieve the journal for the journalvolume and it'll
     then retrieve the volume. This example has 2 Related beans chained to eachother to finally chain to a Collected
     bean to retrieve the final value -->
    <bean class="org.dspace.content.virtual.Related" id="issueVolumeJournal_issn_related">
        <property name="relationshipTypeString" value="isJournalVolumeOfIssue"/>
        <property name="place" value="1"/>
        <property name="virtualBean" ref="volumeJournal_issn_related"/>
    </bean>
</beans>

