<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<HTML>
  <HEAD>
    <TITLE>DSpace System Documentation: Storage Layer</TITLE>
    <LINK REL=StyleSheet HREF="style.css" TYPE="text/css">
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" >
  </HEAD>
  <BODY>
    <H1>DSpace System Documentation: Storage Layer</H1>

    <P><A HREF="index.html">Back to contents</A><BR><A HREF="architecture.html">Back to architecture overview</A></P>

    <H2><A NAME="rdbms">RDBMS</A></H2>

    <P>DSpace uses a relational database to store all information about the organization of content, metadata about the content, information about e-people and authorization, and the state of currently-running workflows.  The DSpace system also uses the relational database in order to maintain indices that users can browse.</P>

    <P>Most of the functionality that DSpace uses can be offered by any standard SQL database that supports transactions.  Presently, the browse indices use some features specific to <A HREF="http://www.postgresql.org/">PostgreSQL</A>, a mature open-source relational database, so some modification to the code would be needed before DSpace would function fully with an alternative database back-end.</P>

    <P>The <code>org.dspace.storage.rdbms</code> package provides access to an SQL database in a somewhat simpler form than using JDBC directly.  The main class is <code>DatabaseManager</code>, which executes SQL queries and returns <code>TableRow</code> or <code>TableRowIterator</code> objects. The <code>InitializeDatabase</code> class is used to load SQL into the database via JDBC, for example to set up the schema.</P>

    <P>All calls to the <code>Database Manager</code> require a <A HREF="business.html#core">DSpace <code>Context</code> object</A>.  Example use of the database manager API is given in the <code>org.dspace.storage.rdbms</code> package Javadoc.</P>

    <P>The database schema used by DSpace is stored in <code><i>[dspace-source]</i>/etc/database_schema.sql</code> in the source distribution.  It is stored in the form of SQL that can be fed straight into the DBMS to construct the database.  The schema SQL file also directly creates two e-person groups in the database that are required for the system to function properly.</P>

    <P>The DSpace database code uses an SQL function <code>getnextid</code> to assign primary keys to newly created rows.  This SQL function must be safe to use if several JVMs are accessing the database at once; for example, the Web UI might be creating new rows in the database at the same time as the batch item importer.  The PostgreSQL-specific implementation of the method uses <code>SEQUENCES</code> for each table in order to create new IDs.  If an alternative database backend were to be used, the implementation of <code>getnextid</code> could be updated to operate with that specific DBMS.</P>

    <P>The <code>etc</code> directory in the source distribution contains two further SQL files.  <code>clean-database.sql</code> contains the SQL necessary to completely clean out the database, so use with caution!  The Ant target <code>clean_database</code> can be used to execute this.  <code>update-sequences.sql</code> contains SQL to reset the primary key generation sequences to appropriate values.  You'd need to do this if, for example, you're restoring a backup database dump which creates rows with specific primary keys already defined.  In such a case, the sequences would allocate primary keys that were already used.</P>


    <H3>Maintenance and Backup</H3>

    <P>When using PostgreSQL, it's a good idea to perform regular 'vacuuming' of the database to optimize performance.  This is performed by the <code>vacuumdb</code> command which can be executed via a 'cron' job, for example by putting this in the system <code>crontab</code>:</P>

    <PRE># clean up the database nightly
40 2 * * * /usr/local/pgsql/bin/vacuumdb --analyze dspace > /dev/null 2>&1</PRE>

    <P>The DSpace database can be backed up and restored using usual methods, for example with <code>pg_dump</code> and <code>psql</code>.  However when restoring a database, you will need to perform these additional steps:</P>

    <UL>
      <LI><P>The <code>fresh_install</code> target loads up the initial contents of the Dublin Core type and bitstream format registries, as well as two entries in the <code>epersongroup</code> table for the system anonymous and administrator groups.  Before you restore a raw backup of your database you will need to remove these, since they will already exist in your backup, possibly having been modified.  For example, use:</P>

      <PRE>DELETE FROM dctyperegistry;
DELETE FROM bitstreamformatregistry;
DELETE FROM epersongroup;</PRE></LI>

      <LI><P>After restoring a backup, you will need to reset the primary key generation sequences so that they do not produce already-used primary keys.  Do this by executing the SQL in <code><i>[dspace-source]</i>/etc/update-sequences.sql</code>, for example with:</P>

      <PRE>psql -U dspace -f <i>[dspace-source]</i>/etc/update-sequences.sql</PRE></LI>
    </UL>

    <P>Future updates of DSpace may involve minor changes to the database schema.  Specific instructions on how to update the schema whilst keeping live data will be included.  The current schema also contains a few currently unused database columns, to be used for extra functionality in future releases.  These unused columns have been added in advance to minimize the effort required to upgrade.</P>


    <H3>Configuring the RDBMS Component</H3>

    <P>The database manager is configured with the following properties in <code>dspace.cfg</code>:</P>

    <table>
      <tr>
        <td><code>db.url</code></td>
        <td>The JDBC URL to use for accessing the database.  This should not point to a connection pool, since DSpace already implements a connection pool.</td>
      </tr>
      <tr>
        <td><code>db.driver</code></td>
        <td>JDBC driver class name.  Since presently, DSpace uses PostgreSQL-specific features, this should be <code>org.postgresql.Driver</code>.</td>
      </tr>
      <tr>
        <td><code>db.username</code></td>
        <td>Username to use when accessing the database.</td>
      </tr>
      <tr>
        <td><code>db.password</code></td>
        <td>Corresponding password ot use when accessing the database.</td>
      </tr>
    </table>


    <H2><A NAME="bitstreams">Bitstream Store</A></H2>

    <P>DSpace currently simply stores content in the file system on the server.  This is achieved using a simple, lightweight API.</P>

    <P>The <code>BitstreamStorageManager</code> provides low-level access to bitstreams stored in the system.  In general, it should not be used directly; instead, use the <code>Bitstream</code> object in the <A HREF="business.html#content">content management API</A> since that encapsulated authorization and other metadata to do with a bitstream that are not maintained by the <code>BitstreamStorageManager</code>.</P>

    <P>The bitstream storage manager provides three methods that store, retrieve and delete bitstreams.  Bitstreams are referred to by their 'ID'; that is the primary key <code>bitstream_id</code> column of the corresponding row in the database.</P>

    <P>As of DSpace version 1.1, there can be multiple bitstream stores.  This means that the potential storage of a DSpace system is not bound by the maximum size of a single disk or file system.</P>

    <P>Stores are numbered, starting with zero, then counting upwards.  Each bitstream entry in the database has a store number, used to retrieve the bitstream when required.</P>

    <P>At the moment, the store in which new bitstreams are placed is decided using a configuration parameter, and there is no provision for moving bitstreams between stores.  Administrative tools for manipulating bitstreams and stores will be provided in future releases.  Right now you can move a whole store (e.g. you could move store number 1 from <code>/localdisk/store</code> to <code>/fs/anotherdisk/store</code> but it would still have to be store number 1 and have the exact same contents.</P>

    <P>Bitstreams also have an 38-digit internal ID, different from the primary key ID of the bitstream table row.  This is not visible or used outside of the bitstream storage manager.  It is used to determine the exact location (relative to the relevant store directory) that the bitstream is stored in the file system.  The first three pairs of digits are the directory path that the bitstream is stored under.  The bitstream is stored in a file with the internal ID as the filename.</P>

    <P>For example, a bitstream with the internal ID <code>12345678901234567890123456789012345678</code> is stored in the directory:</P>

    <PRE>(assetstore dir)/12/34/56/12345678901234567890123456789012345678</PRE>

    <P>The reasons for storing files this way are:</P>

    <UL>
      <LI><P>Using a randomly-generated 38-digit number means that the 'number space' is less cluttered than simply using the primary keys, which are allocated sequentially and are thus close together.  This means that the bitstreams in the store are distributed around the directory structure, improving access efficiency.</P></LI>

      <LI><P>The internal ID is used as the filename partly to avoid requiring an extra lookup of the filename of the bitstream, and partly because bitstreams may be received from a variety of operating systems.  The original name of a bitstream may be an illegal UNIX filename.</P></LI>
    </UL>

     <P>When storing a bitstream, the <code>BitstreamStorageManager</code> DOES set the following fields in the corresponding database table row:</P>

    <UL>
      <LI><code>bitstream_id</code></LI>
      <LI><code>size</code></LI>
      <LI><code>checksum</code></LI>
      <LI><code>checksum_algorithm</code></LI>
      <LI><code>internal_id</code></LI>
      <LI><code>deleted</code></LI>
      <LI><code>store_number</code></LI>
    </UL>

    <P>The remaining fields are the responsibility of the <code>Bitstream</code> content management API class.</P>

    <P>The bitstream storage manager is fully transaction-safe.  In order to implement transaction-safety, the following algorithm is used to store bitstreams:</P>

    <OL>
      <LI>A database connection is created, separately from the currently active connection in the <A HREF="business.html#core">current DSpace context</A>.</LI>
      <LI>An unique internal identifier (separate from the database primary key) is generated.</LI>
      <LI>The bitstream DB table row is created using this new connection, with the <code>deleted</code> column set to <code>true</code>.</LI>
      <LI>The new connection is <code>commit</code>ted, so the 'deleted' bitstream row is written to the database</LI>
      <LI>The bitstream itself is stored in a file in the configured 'asset store directory', with a directory path and filename derived from the internal ID</LI>
      <LI>The <code>deleted</code> flag in the bitstream row is set to <code>false</code>.  This will occur (or not) as part of the current DSpace <code>Context</code>.</LI>
    </OL>

    <P>This means that should anything go wrong before, during or after the bitstream storage, only one of the following can be true:</P>

    <UL>
      <LI>No bitstream table row was created, and no file was stored</LI>
      <LI>A bitstream table row with <code>deleted=true</code> was created, no file was stored</LI>
      <LI>A bitstream table row with <code>deleted=true</code> was created, and a file was stored</LI>
    </UL>

    <P>None of these affect the integrity of the data in the database or bitstream store.</P>

    <P>Similarly, when a bitstream is deleted for some reason, its <code>deleted</code> flag is set to true as part of the overall transaction, and the corresponding file in the filesystem is <em>not</em> deleted.</P>

    <P>The above techniques mean that the bitstream storage manager is transaction-safe.  Over time, the bitstream database table and file store may contain a number of 'deleted' bitstreams.  The <code>cleanup</code> method of <code>BitstreamStorageManager</code> goes through these deleted rows, and actually deletes them along with any corresponding files left in the file system.  It only removes 'deleted' bitstreams that are more than one hour old, just in case cleanup is happening in the middle of a storage operation.</P>

    <P>This cleanup can be invoked from the command line via the <code>Cleanup</code> class, which can in turn be easily executed from a shell on the server machine using <code>/dspace/bin/cleanup</code>.  You might like to have this run regularly by <code>cron</code>, though since DSpace is read-lots, write-not-so-much it doesn't need to be run very often.</P>

    <H3>Backup</H3>

    <P>The bitstreams (files) in the bitstream store may be backed up very easily by simply 'tarring' or 'zipping' the <code>assetstore</code> directory (or whichever directory is configured in <code>dspace.cfg</code>.  Restoring is as simple as extracting the backed-up compressed file in the appropriate location.</P>

    <P>It is important to note that since the bitstream storage manager holds the bitstreams in the file system, and information about them in the database, that a database backup and a backup of the files in the bitstream store must be made at the same time; the bitstream data in the database must correspond to the stored files.</P>

    <P>Of course, it isn't really ideal to 'freeze' the system while backing up to ensure that the database and files match up.  Since DSpace uses the bitstream data in the database as the authoritative record, it's best to back up the database before the files.  This is because it's better to have a bitstream in the file system but not the database (effectively non-existent to DSpace) than a bitstream record in the database but not the file system, since people would be able to find the bitstream but not actually get the contents.</P>


    <H3>Configuring the Bitstream Store</H3>

    <P>The bitstream stores (also called 'asset stores') can be configured in <code>dspace.cfg</code>. For example:</P>

    <PRE>assetstore.dir = <i>[dspace]</i>/assetstore</PRE>

    <P>(Remember that <i>[dspace]</i> is a placeholder for the actual name of your DSpace install directory).</P>

    <P>The above example specifies a single asset store.</P>

    <PRE>assetstore.dir = <i>[dspace]</i>/assetstore_0
assetstore.dir.1 = /mnt/other_filesystem/assetstore_1</PRE>

    <P>The above example specifies two asset stores. assetstore.dir specifies the asset store number 0 (zero); after that use assetstore.dir.1, assetstore.dir.2 and so on. The particular asset store a bitstream is stored in is held in the database, so don't move bitstreams between asset stores, and don't renumber them.</P>

    <P>By default, newly created bitstreams are put in asset store 0 (i.e. the one specified by the assetstore.dir property.)  This allows backwards compatibility with pre-DSpace 1.1 configurations.  To change this, for example when asset store 0 is getting full, add a line to <code>dspace.cfg</code> like:</P>

    <PRE>assetstore.incoming = 1</PRE>

    <P>Then restart DSpace (Tomcat). New bitstreams will be written to the asset store specified by <code>assetstore.dir.1</code>, which is <code>/mnt/other_filesystem/assetstore_1</code> in the above example.</P>

    <HR>

    <ADDRESS>
     Copyright &copy; 2002-2004 MIT and Hewlett Packard
    </ADDRESS>
  </BODY>
</HTML>
